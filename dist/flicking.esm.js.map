{"version":3,"file":"flicking.esm.js","sources":["../src/consts.ts","../src/utils.ts","../src/components/Panel.ts","../src/components/PanelManager.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/moves/MoveType.ts","../src/moves/Snap.ts","../src/moves/FreeScroll.ts","../src/components/Viewport.ts","../src/components/AutoResizer.ts","../src/Flicking.ts"],"sourcesContent":["/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { FlickingOptions, EventType, Direction, AxesEventType, StateType, MoveTypeSnapOption, MoveTypeFreeScrollOption, FlickingMethodsKeys } from \"./types\";\n\nexport const MOVE_TYPE: {\n  SNAP: \"snap\";\n  FREE_SCROLL: \"freeScroll\";\n} = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n};\n\nexport const DEFAULT_MOVE_TYPE_OPTIONS: {\n  snap: MoveTypeSnapOption,\n  freeScroll: MoveTypeFreeScrollOption,\n} = {\n  snap: {\n    type: \"snap\",\n    count: 1,\n  },\n  freeScroll: {\n    type: \"freeScroll\",\n  },\n};\nexport const isBrowser = typeof document !== \"undefined\";\n\n/**\n * Default options for creating Flicking.\n * @ko 플리킹을 만들 때 사용하는 기본 옵션들\n * @private\n * @memberof eg.Flicking\n */\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n  useOffset: false,\n  isEqualSize: false,\n  isConstantSize: false,\n  renderOnlyVisible: false,\n  renderExternal: false,\n  resizeOnContentsReady: false,\n  iOSEdgeSwipeThreshold: 30,\n  collectStatistics: true,\n  useResizeObserver: true,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n  CONTENT_LOAD: \"contentLoad\",\n  CONTENT_ERROR: \"contentError\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\nexport const FLICKING_METHODS: {[key in FlickingMethodsKeys]: true} = {\n  prev: true,\n  next: true,\n  moveTo: true,\n  getIndex: true,\n  getAllPanels: true,\n  getCurrentPanel: true,\n  getElement: true,\n  getSize: true,\n  getPanel: true,\n  getPanelCount: true,\n  getStatus: true,\n  getVisiblePanels: true,\n  enableInput: true,\n  disableInput: true,\n  destroy: true,\n  resize: true,\n  setStatus: true,\n  isPlaying: true,\n};\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  if (!isBrowser) {\n    return {\n      name: transforms.transform,\n      has3d: true,\n    };\n  }\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { ElementLike, OriginalStyle, BoundingBox } from \"./types\";\nimport Flicking from \"./Flicking\";\nimport { FLICKING_METHODS } from \"./consts\";\n\nexport function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\nexport function parseElement(element: ElementLike | ElementLike[]): HTMLElement[] {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else {\n      elements.push(el as HTMLElement);\n    }\n  });\n\n  return elements;\n}\n\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (!hasClass(element, className)) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function hasClass(element: HTMLElement, className: string): boolean {\n  if (element.classList) {\n    return element.classList.contains(className);\n  } else {\n    return (element.className.split(\" \").indexOf(className) >= 0);\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element != null && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function counter(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n\n// Circulate number between range [min, max]\n/*\n * \"indexed\" means min and max is not same, so if it's true \"min - 1\" should be max\n * While if it's false, \"min - 1\" should be \"max - 1\"\n * use `indexed: true` when it should be used for circulating integers like index\n * or `indexed: false` when it should be used for something like positions.\n */\nexport function circulate(value: number, min: number, max: number, indexed: boolean): number {\n  const size = indexed\n    ? max - min + 1\n    : max - min;\n  if (value < min) {\n    const offset = indexed\n      ? (min - value - 1) % size\n      : (min - value) % size;\n    value = max - offset;\n  } else if (value > max) {\n    const offset = indexed\n      ? (value - max - 1) % size\n      : (value - max) % size;\n    value = min + offset;\n  }\n\n  return value;\n}\n\nexport function restoreStyle(element: HTMLElement, originalStyle: OriginalStyle): void {\n  originalStyle.className\n    ? element.setAttribute(\"class\", originalStyle.className)\n    : element.removeAttribute(\"class\");\n  originalStyle.style\n    ? element.setAttribute(\"style\", originalStyle.style)\n    : element.removeAttribute(\"style\");\n}\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nexport function withFlickingMethods(prototype: any, flickingName: string) {\n  Object.keys(FLICKING_METHODS).forEach((name: keyof Flicking) => {\n    if (prototype[name]) {\n      return;\n    }\n    prototype[name] = function(...args) {\n      const result = this[flickingName][name](...args);\n\n      // fix `this` type to return your own `flicking` instance to the instance using the decorator.\n      if (result === this[flickingName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n\nexport function getBbox(element: HTMLElement, useOffset: boolean) {\n  let bbox: BoundingBox;\n  if (useOffset) {\n    bbox = {\n      x: 0,\n      y: 0,\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n    };\n  } else {\n    const clientRect = element.getBoundingClientRect();\n    bbox = {\n      x: clientRect.left,\n      y: clientRect.top,\n      width: clientRect.width,\n      height: clientRect.height,\n    };\n  }\n  return bbox;\n}\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Viewport from \"./Viewport\";\nimport { OriginalStyle, FlickingPanel, ElementLike, DestroyOption, BoundingBox } from \"../types\";\nimport { DEFAULT_PANEL_CSS, EVENTS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression, parseElement, getProgress, restoreStyle, hasClass, getBbox } from \"../utils\";\n\nclass Panel implements FlickingPanel {\n  public viewport: Viewport;\n  public prevSibling: Panel | null;\n  public nextSibling: Panel | null;\n\n  protected state: {\n    index: number;\n    position: number;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    isVirtual: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    cachedBbox: BoundingBox | null;\n  };\n  private element: HTMLElement;\n  private original?: Panel;\n  private clonedPanels: Panel[];\n\n  public constructor(\n    element?: HTMLElement | null,\n    index?: number,\n    viewport?: Viewport,\n  ) {\n    this.viewport = viewport!;\n    this.prevSibling = null;\n    this.nextSibling = null;\n    this.clonedPanels = [];\n\n    this.state = {\n      index: index!,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      isClone: false,\n      isVirtual: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: \"\",\n        style: \"\",\n      },\n      cachedBbox: null,\n    };\n    this.setElement(element);\n  }\n\n  public resize(givenBbox?: BoundingBox): void {\n    const state = this.state;\n    const options = this.viewport.options;\n    const bbox = givenBbox\n      ? givenBbox\n      : this.getBbox();\n    this.state.cachedBbox = bbox;\n    const prevSize = state.size;\n\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    if (prevSize !== state.size) {\n      state.relativeAnchorPosition = parseArithmeticExpression(options.anchor, state.size);\n    }\n\n    if (!state.isClone) {\n      this.clonedPanels.forEach(panel => {\n        const cloneState = panel.state;\n\n        cloneState.size = state.size;\n        cloneState.cachedBbox = state.cachedBbox;\n        cloneState.relativeAnchorPosition = state.relativeAnchorPosition;\n      });\n    }\n  }\n\n  public unCacheBbox(): void {\n    this.state.cachedBbox = null;\n  }\n\n  public getProgress() {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const panelCount = viewport.panelManager.getPanelCount();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n\n    const relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n    const progress = relativeIndex - viewport.getCurrentProgress();\n\n    return progress;\n  }\n\n  public getOutsetProgress() {\n    const viewport = this.viewport;\n    const outsetRange = [\n      -this.getSize(),\n      viewport.getRelativeHangerPosition() - this.getRelativeAnchorPosition(),\n      viewport.getSize(),\n    ];\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const outsetProgress = getProgress(relativePanelPosition, outsetRange);\n\n    return outsetProgress;\n  }\n\n  public getVisibleRatio() {\n    const viewport = this.viewport;\n    const panelSize = this.getSize();\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const rightRelativePanelPosition = relativePanelPosition + panelSize;\n\n    const visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    const visibleRatio = visibleSize >= 0\n      ? visibleSize / panelSize\n      : 0;\n\n    return visibleRatio;\n  }\n\n  public focus(duration?: number): void {\n    const viewport = this.viewport;\n    const currentPanel = viewport.getCurrentPanel();\n    const hangerPosition = viewport.getHangerPosition();\n    const anchorPosition = this.getAnchorPosition();\n    if (hangerPosition === anchorPosition || !currentPanel) {\n      return;\n    }\n\n    const currentPosition = currentPanel.getPosition();\n    const eventType = currentPosition === this.getPosition()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(this, viewport.findEstimatedPosition(this), eventType, null, duration);\n  }\n\n  public update(updateFunction: ((element: HTMLElement) => any) | null = null, shouldResize: boolean = true): void {\n    const identicalPanels = this.getIdenticalPanels();\n\n    if (updateFunction) {\n      identicalPanels.forEach(eachPanel => {\n        updateFunction(eachPanel.getElement());\n      });\n    }\n\n    if (shouldResize) {\n      identicalPanels.forEach(eachPanel => {\n        eachPanel.unCacheBbox();\n      });\n      this.viewport.addVisiblePanel(this);\n      this.viewport.resize();\n    }\n  }\n\n  public prev(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const prevSibling = this.prevSibling;\n\n    if (!prevSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const prevPanelIndex = prevSibling.getIndex();\n    const prevPanelPosition = prevSibling.getPosition();\n    const prevPanelSize = prevSibling.getSize();\n\n    const hasEmptyPanelBetween = currentIndex - prevPanelIndex > 1;\n    const notYetMinPanel = options.infinite\n      && currentIndex > 0\n      && prevPanelIndex > currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMinPanel) {\n      // Empty panel exists between\n      return null;\n    }\n\n    const newPosition = currentPosition - prevPanelSize - options.gap;\n\n    let prevPanel = prevSibling;\n    if (prevPanelPosition !== newPosition) {\n      prevPanel = prevSibling.clone(prevSibling.getCloneIndex(), true);\n      prevPanel.setPosition(newPosition);\n    }\n\n    return prevPanel;\n  }\n\n  public next(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const nextSibling = this.nextSibling;\n    const lastIndex = viewport.panelManager.getLastIndex();\n\n    if (!nextSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const nextPanelIndex = nextSibling.getIndex();\n    const nextPanelPosition = nextSibling.getPosition();\n\n    const hasEmptyPanelBetween = nextPanelIndex - currentIndex > 1;\n    const notYetMaxPanel = options.infinite\n      && currentIndex < lastIndex\n      && nextPanelIndex < currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMaxPanel) {\n      return null;\n    }\n\n    const newPosition = currentPosition + this.getSize() + options.gap;\n\n    let nextPanel = nextSibling;\n    if (nextPanelPosition !== newPosition) {\n      nextPanel = nextSibling.clone(nextSibling.getCloneIndex(), true);\n      nextPanel.setPosition(newPosition);\n    }\n\n    return nextPanel;\n  }\n\n  public insertBefore(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n    const firstPanel = viewport.panelManager.firstPanel()!;\n    const prevSibling = this.prevSibling;\n    // Finding correct inserting index\n    // While it should insert removing empty spaces,\n    // It also should have to be bigger than prevSibling' s index\n    const targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex()\n      ? Math.max(prevSibling.getIndex() + 1, this.getIndex() - parsedElements.length)\n      : Math.max(this.getIndex() - parsedElements.length, 0);\n\n    return viewport.insert(targetIndex, parsedElements);\n  }\n\n  public insertAfter(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.insert(this.getIndex() + 1, element);\n  }\n\n  public remove(): FlickingPanel {\n    this.viewport.remove(this.getIndex());\n\n    return this;\n  }\n\n  public destroy(option: Partial<DestroyOption>): void {\n    if (!option.preserveUI) {\n      const originalStyle = this.state.originalStyle;\n\n      restoreStyle(this.element, originalStyle);\n    }\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getBbox(): BoundingBox {\n    const state = this.state;\n    const viewport = this.viewport;\n    const element = this.element;\n    const options = viewport.options;\n\n    if (!element) {\n      state.cachedBbox = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n      };\n    } else if (!state.cachedBbox) {\n      const wasVisible = Boolean(element.parentNode);\n      const cameraElement = viewport.getCameraElement();\n      if (!wasVisible) {\n        cameraElement.appendChild(element);\n        viewport.addVisiblePanel(this);\n      }\n      state.cachedBbox = getBbox(element, options.useOffset);\n\n      if (!wasVisible && viewport.options.renderExternal) {\n        cameraElement.removeChild(element);\n      }\n    }\n    return state.cachedBbox!;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getOverlappedClass(classes: string[]): string | undefined {\n    const element = this.element;\n\n    for (const className of classes) {\n      if (hasClass(element, className)) {\n        return className;\n      }\n    }\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getClonedPanels()\n      : this.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...this.clonedPanels];\n  }\n\n  public getOriginalPanel(): Panel {\n    return this.state.isClone\n      ? this.original!\n      : this;\n  }\n\n  public setIndex(index: number): void {\n    const state = this.state;\n\n    state.index = index;\n    this.clonedPanels.forEach(panel => panel.state.index = index);\n  }\n\n  public setPosition(pos: number): this {\n    this.state.position = pos;\n\n    return this;\n  }\n\n  public setPositionCSS(offset: number = 0): void {\n    if (!this.element) {\n      return;\n    }\n    const state = this.state;\n    const pos = state.position;\n    const options = this.viewport.options;\n    const elementStyle = this.element.style;\n    const currentElementStyle = options.horizontal\n      ? elementStyle.left\n      : elementStyle.top;\n    const styleToApply = `${pos - offset}px`;\n\n    if (!state.isVirtual && currentElementStyle !== styleToApply) {\n      options.horizontal\n        ? elementStyle.left = styleToApply\n        : elementStyle.top = styleToApply;\n    }\n  }\n\n  public clone(cloneIndex: number, isVirtual: boolean = false, element?: HTMLElement | null): Panel {\n    const state = this.state;\n    const viewport = this.viewport;\n    let cloneElement = element;\n\n    if (!cloneElement && this.element) {\n      cloneElement = isVirtual ? this.element : this.element.cloneNode(true) as HTMLElement;\n    }\n    const clonedPanel = new Panel(cloneElement, state.index, viewport);\n    const clonedState = clonedPanel.state;\n\n    clonedPanel.original = state.isClone\n      ? this.original\n      : this;\n    clonedState.isClone = true;\n    clonedState.isVirtual = isVirtual;\n    clonedState.cloneIndex = cloneIndex;\n    // Inherit some state values\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n\n    if (!isVirtual) {\n      this.clonedPanels.push(clonedPanel);\n    } else {\n      clonedPanel.prevSibling = this.prevSibling;\n      clonedPanel.nextSibling = this.nextSibling;\n    }\n\n    return clonedPanel;\n  }\n\n  public removeElement(): void {\n    if (!this.viewport.options.renderExternal) {\n      const element = this.element;\n      element.parentNode && element.parentNode.removeChild(element);\n    }\n\n    // Do the same thing for clones\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const options = this.viewport.options;\n    const removingPanels = this.clonedPanels.splice(start);\n\n    if (!options.renderExternal) {\n      removingPanels.forEach(panel => {\n        panel.removeElement();\n      });\n    }\n  }\n\n  public setElement(element?: HTMLElement | null): void {\n    if (!element) {\n      return;\n    }\n    const currentElement = this.element;\n    if (element !== currentElement) {\n      const options = this.viewport.options;\n\n      if (currentElement) {\n        if (options.horizontal) {\n          element.style.left = currentElement.style.left;\n        } else {\n          element.style.top = currentElement.style.top;\n        }\n      } else {\n        const originalStyle = this.state.originalStyle;\n\n        originalStyle.className = element.getAttribute(\"class\");\n        originalStyle.style = element.getAttribute(\"style\");\n      }\n\n      this.element = element;\n\n      if (options.classPrefix) {\n        addClass(element, `${options.classPrefix}-panel`);\n      }\n\n      // Update size info after applying panel css\n      applyCSS(this.element, DEFAULT_PANEL_CSS);\n    }\n  }\n}\n\nexport default Panel;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Panel from \"./Panel\";\nimport { FlickingOptions } from \"../types\";\nimport { findIndex, counter } from \"../utils\";\n\nclass PanelManager {\n  private cameraElement: HTMLElement;\n  private options: FlickingOptions;\n  private panels: Panel[];\n  private clones: Panel[][];\n  // index range of existing panels\n  private range: {\n    min: number;\n    max: number;\n  };\n  private length: number;\n  private lastIndex: number;\n  private cloneCount: number;\n\n  constructor(\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n    this.length = 0;\n    this.cloneCount = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  public firstPanel(): Panel | undefined {\n    return this.panels[this.range.min];\n  }\n\n  public lastPanel(): Panel | undefined {\n    return this.panels[this.range.max];\n  }\n\n  public allPanels(): ReadonlyArray<Panel> {\n    return [\n      ...this.panels,\n      ...this.clones.reduce((allClones, clones) => [...allClones, ...clones], []),\n    ];\n  }\n\n  public originalPanels(): ReadonlyArray<Panel> {\n    return this.panels;\n  }\n\n  public clonedPanels(): ReadonlyArray<Panel[]> {\n    return this.clones;\n  }\n\n  public replacePanels(newPanels: Panel[], newClones: Panel[][]): void {\n    this.panels = newPanels;\n    this.clones = newClones;\n\n    this.range = {\n      min: findIndex(newPanels, panel => Boolean(panel)),\n      max: newPanels.length - 1,\n    };\n    this.length = newPanels.filter(panel => Boolean(panel)).length;\n    this.chainAllPanels();\n  }\n\n  public has(index: number): boolean {\n    return !!this.panels[index];\n  }\n\n  public get(index: number): Panel | undefined {\n    return this.panels[index];\n  }\n\n  public getPanelCount(): number {\n    return this.length;\n  }\n\n  public getLastIndex(): number {\n    return this.lastIndex;\n  }\n\n  public getRange(): Readonly<{ min: number, max: number }> {\n    return this.range;\n  }\n\n  public getCloneCount(): number {\n    return this.cloneCount;\n  }\n\n  public setLastIndex(lastIndex: number): void {\n    this.lastIndex = lastIndex;\n\n    const firstPanel = this.firstPanel();\n    const lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    }\n\n    // Remove panels above new last index\n    const range = this.range;\n    if (lastPanel.getIndex() > lastIndex) {\n      const removingPanels = this.panels.splice(lastIndex + 1);\n      this.length -= removingPanels.length;\n\n      const firstRemovedPanel = removingPanels.filter(panel => !!panel)[0];\n      const possibleLastPanel = firstRemovedPanel.prevSibling;\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n\n      if (this.shouldRender()) {\n        removingPanels.forEach(panel => panel.removeElement());\n      }\n    }\n  }\n\n  public setCloneCount(cloneCount: number): void {\n    this.cloneCount = cloneCount;\n  }\n\n  // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n  public insert(index: number, newPanels: Panel[]): number {\n    const panels = this.panels;\n    const range = this.range;\n    const isCircular = this.options.circular;\n    const lastIndex = this.lastIndex;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    let pushedIndex = newPanels.length;\n    // Like when setting index 50 while visible panels are 0, 1, 2\n    if (index > range.max) {\n      newPanels.forEach((panel, offset) => {\n        panels[index + offset] = panel;\n      });\n    } else {\n      const panelsAfterIndex = panels.slice(index, index + newPanels.length);\n      // Find empty from beginning\n      let emptyPanelCount = findIndex(panelsAfterIndex, panel => !!panel);\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n      pushedIndex = newPanels.length - emptyPanelCount;\n\n      // Insert removing empty panels\n      panels.splice(index, emptyPanelCount, ...newPanels);\n\n      // Remove panels after last index\n      if (panels.length > lastIndex + 1) {\n        const removedPanels = panels.splice(lastIndex + 1)\n          .filter(panel => Boolean(panel));\n        this.length -= removedPanels.length;\n\n        // Find first\n        const newLastIndex = lastIndex - findIndex(this.panels.concat().reverse(), panel => !!panel);\n\n        // Can be filled with empty after newLastIndex\n        this.panels.splice(newLastIndex + 1);\n        this.range.max = newLastIndex;\n\n        if (this.shouldRender()) {\n          removedPanels.forEach(panel => panel.removeElement());\n        }\n      }\n    }\n\n    // Update index of previous panels\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(panel => {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    }\n\n    // Update state\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n      const clones = this.clones;\n      const panelCount = this.panels.length;\n      if (clones[0] && clones[0].length > lastIndex + 1) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(panelCount);\n        });\n      }\n    }\n\n    return pushedIndex;\n  }\n\n  public replace(index: number, newPanels: Panel[]): Panel[] {\n    const panels = this.panels;\n    const range = this.range;\n    const options = this.options;\n    const isCircular = options.circular;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index + newPanels.length);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      (panels[index] as any) = null;\n    }\n    const replacedPanels = panels.splice(index, newPanels.length, ...newPanels);\n    const wasNonEmptyCount = replacedPanels.filter(panel => Boolean(panel)).length;\n\n    // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n\n    if (this.shouldRender()) {\n      replacedPanels.forEach(panel => panel && panel.removeElement());\n    }\n\n    return replacedPanels;\n  }\n\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    const isCircular = this.options.circular;\n    const panels = this.panels;\n    const clones = this.clones;\n    // Delete count should be equal or larger than 0\n    deleteCount = Math.max(deleteCount, 0);\n\n    const deletedPanels = panels\n      .splice(index, deleteCount)\n      .filter(panel => !!panel);\n\n    if (this.shouldRender()) {\n      deletedPanels.forEach(panel => panel.removeElement());\n    }\n\n    if (isCircular) {\n      clones.forEach(cloneSet => {\n        cloneSet.splice(index, deleteCount);\n      });\n    }\n\n    // Update indexes\n    panels\n      .slice(index)\n      .forEach(panel => {\n        panel.setIndex(panel.getIndex() - deleteCount);\n      });\n\n    // Check last panel is empty\n    let lastIndex = panels.length - 1;\n    if (!panels[lastIndex]) {\n      const reversedPanels = panels.concat().reverse();\n      const nonEmptyIndexFromLast = findIndex(reversedPanels, panel => !!panel);\n      lastIndex = nonEmptyIndexFromLast < 0\n        ? -1 // All empty\n        : lastIndex - nonEmptyIndexFromLast;\n\n      // Remove all empty panels from last\n      panels.splice(lastIndex + 1);\n      if (isCircular) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    }\n\n    // Update range & length\n    this.range = {\n      min: findIndex(panels, panel => !!panel),\n      max: lastIndex,\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n      this.cloneCount = 0;\n    }\n\n    return deletedPanels;\n  }\n\n  public chainAllPanels() {\n    const allPanels = this.allPanels().filter(panel => !!panel);\n    const allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 1) {\n      if (allPanelsCount === 1) {\n        allPanels[0].prevSibling = null;\n        allPanels[0].nextSibling = null;\n      }\n      return;\n    }\n\n    allPanels.slice(1, allPanels.length - 1).forEach((panel, idx) => {\n      const prevPanel = allPanels[idx];\n      const nextPanel = allPanels[idx + 2];\n\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n\n    const firstPanel = allPanels[0];\n    const lastPanel = allPanels[allPanelsCount - 1];\n\n    firstPanel.prevSibling = null;\n    firstPanel.nextSibling = allPanels[1];\n    lastPanel.prevSibling = allPanels[allPanelsCount - 2];\n    lastPanel.nextSibling = null;\n\n    if (this.options.circular) {\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  }\n\n  public insertClones(cloneIndex: number, index: number, clonedPanels: Panel[], deleteCount: number = 0): void {\n    const clones = this.clones;\n    const lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      const newClones: Panel[] = [];\n      clonedPanels.forEach((panel, offset) => {\n        newClones[index + offset] = panel;\n      });\n\n      clones[cloneIndex] = newClones;\n    } else {\n      const insertTarget = clones[cloneIndex];\n\n      if (index >= insertTarget.length) {\n        clonedPanels.forEach((panel, offset) => {\n          insertTarget[index + offset] = panel;\n        });\n      } else {\n        insertTarget.splice(index, deleteCount, ...clonedPanels);\n        // Remove panels after last index\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }\n\n  // clones are operating in set\n  public removeClonesAfter(cloneIndex: number): void {\n    const panels = this.panels;\n\n    panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    const allPanels = this.allPanels();\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findFirstPanelFrom(index: number): Panel | undefined {\n    for (const panel of this.panels.slice(index)) {\n      if (panel && panel.getIndex() >= index && panel.getElement().parentNode) {\n        return panel;\n      }\n    }\n  }\n\n  private addNewClones(index: number, originalPanels: Panel[], deleteCount: number, nextSibling: Panel | undefined) {\n    const cameraElement = this.cameraElement;\n    const cloneCount = this.getCloneCount();\n    const lastPanel = this.lastPanel();\n    const lastPanelClones: Panel[] = lastPanel\n      ? lastPanel.getClonedPanels()\n      : [];\n    const nextSiblingClones: Panel[] = nextSibling\n      ? nextSibling.getClonedPanels()\n      : [];\n\n    for (const cloneIndex of counter(cloneCount)) {\n      const cloneNextSibling = nextSiblingClones[cloneIndex];\n      const lastPanelSibling = lastPanelClones[cloneIndex];\n\n      const cloneSiblingElement = cloneNextSibling\n        ? cloneNextSibling.getElement()\n        : lastPanelSibling\n          ? lastPanelSibling.getElement().nextElementSibling\n          : null;\n\n      const newClones = originalPanels.map(panel => {\n        const clone = panel.clone(cloneIndex);\n\n        if (this.shouldRender()) {\n          cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        }\n\n        return clone;\n      });\n\n      this.insertClones(cloneIndex, index, newClones, deleteCount);\n    }\n  }\n\n  private updateIndex(insertingIndex: number) {\n    const panels = this.panels;\n    const range = this.range;\n\n    const newLastIndex = panels.length - 1;\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  }\n\n  private insertNewPanels(newPanels: Panel[], siblingElement: HTMLElement | null) {\n    if (this.shouldRender()) {\n      const fragment = document.createDocumentFragment();\n      newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n      this.cameraElement.insertBefore(fragment, siblingElement);\n    }\n  }\n\n  private shouldRender(): boolean {\n    const options = this.options;\n\n    return !options.renderExternal && !options.renderOnlyVisible;\n  }\n}\n\nexport default PanelManager;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport type { OnAnimationEnd, OnChange, OnFinish, OnHold, OnRelease } from \"@egjs/axes\";\nimport Panel from \"../components/Panel\";\nimport { ValueOf, Direction, StateType, FlickingContext } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: Panel | null = null;\n  public lastPosition: number = 0;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.lastPosition = prevState.lastPosition;\n  }\n\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n\n  public onHold(e: OnHold, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onChange(e: OnChange, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onRelease(e: OnRelease, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onAnimationEnd(e: OnAnimationEnd, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onFinish(e: OnFinish, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport type { OnHold, OnChange } from \"@egjs/axes\";\nimport State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.lastPosition = 0;\n  }\n\n  public onHold(e: OnHold, { flicking, viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Shouldn't do any action until any panels on flicking area\n    if (flicking.getPanelCount() <= 0) {\n      if (viewport.options.infinite) {\n        viewport.moveCamera(viewport.getCameraPosition(), e);\n      }\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    this.lastPosition = viewport.getCameraPosition();\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: OnChange, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport type { OnChange, OnRelease, OnFinish } from \"@egjs/axes\";\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext, SelectEvent } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: OnChange, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: OnRelease, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    if (!e.inputEvent.srcEvent.cancelable) {\n      // Released by scrolling\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: OnFinish, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const srcEvent = releaseEvent.inputEvent.srcEvent;\n\n    let clickedElement: HTMLElement;\n    if (srcEvent.type === \"touchend\") {\n      const touchEvent = srcEvent as TouchEvent;\n      const touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY) as HTMLElement;\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    const clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent<SelectEvent>(EVENTS.SELECT, releaseEvent, true, {\n        direction, // Direction to the clicked panel\n        index: clickedPanel.getIndex(),\n        panel: clickedPanel,\n        element: clickedElement,\n      });\n    }\n  }\n}\n\nexport default HoldingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport type { OnChange, OnRelease } from \"@egjs/axes\";\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onChange(e: OnChange, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: OnRelease, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, transitTo, stopCamera } = context;\n\n    const delta = this.delta;\n    const absDelta = Math.abs(delta);\n    const options = flicking.options;\n    const horizontal = options.horizontal;\n    const moveType = viewport.moveType;\n    const inputEvent = e.inputEvent;\n\n    const velocity = horizontal\n      ? inputEvent.velocityX\n      : inputEvent.velocityY;\n    const inputDelta = horizontal\n      ? inputEvent.deltaX\n      : inputEvent.deltaY;\n    const isNextDirection = Math.abs(velocity) > 1\n      ? velocity < 0\n      : absDelta > 0\n        ? delta > 0\n        : inputDelta < 0;\n\n    const swipeDistance = viewport.options.bound\n      ? Math.max(absDelta, Math.abs(inputDelta))\n      : absDelta;\n    const swipeAngle = inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI)\n      : 90;\n    const belowAngleThreshold = horizontal\n      ? swipeAngle <= options.thresholdAngle\n      : swipeAngle > options.thresholdAngle;\n    const overThreshold = swipeDistance >= options.threshold\n      && belowAngleThreshold;\n\n    const moveTypeContext = {\n      viewport,\n      axesEvent: e,\n      state: this,\n      swipeDistance,\n      isNextDirection,\n    };\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    const targetPanel = this.targetPanel;\n    if (!overThreshold && targetPanel) {\n      // Interrupted while animating\n      const interruptDestInfo = moveType.findPanelWhenInterrupted(moveTypeContext);\n\n      viewport.moveTo(\n        interruptDestInfo.panel,\n        interruptDestInfo.destPos,\n        interruptDestInfo.eventType,\n        e,\n        interruptDestInfo.duration,\n      );\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      (e as any).stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    const destInfo = overThreshold\n      ? moveType.findTargetPanel(moveTypeContext)\n      : moveType.findRestorePanel(moveTypeContext);\n\n    viewport.moveTo(\n      destInfo.panel,\n      destInfo.destPos,\n      destInfo.eventType,\n      e,\n      destInfo.duration,\n    ).onSuccess(() => {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(() => {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  }\n}\n\nexport default DraggingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport type { OnChange, OnFinish, OnHold } from \"@egjs/axes\";\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: OnHold, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    const options = viewport.options;\n    const scrollArea = viewport.getScrollArea();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const loopCount = Math.floor((this.lastPosition + this.delta - scrollArea.prev) / scrollAreaSize);\n\n    const targetPanel = this.targetPanel;\n    if (options.circular && loopCount !== 0 && targetPanel) {\n      const cloneCount = viewport.panelManager.getCloneCount();\n      const originalTargetPosition = targetPanel.getPosition();\n\n      // cloneIndex is from -1 to cloneCount - 1\n      const newCloneIndex = circulate(targetPanel.getCloneIndex() - loopCount, -1, cloneCount - 1, true);\n      const newTargetPosition = originalTargetPosition - loopCount * scrollAreaSize;\n      const newTargetPanel = targetPanel.getIdenticalPanels()[newCloneIndex + 1].clone(newCloneIndex, true);\n\n      // Set new target panel considering looped count\n      newTargetPanel.setPosition(newTargetPosition);\n      this.targetPanel = newTargetPanel;\n    }\n\n    // Reset last position and delta\n    this.delta = 0;\n    this.lastPosition = viewport.getCameraPosition();\n\n    // Update current panel as current nearest panel\n    viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: OnChange, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: OnFinish, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n\n    viewport.options.bound\n      ? viewport.setCurrentPanel(this.targetPanel!)\n      : viewport.setCurrentPanel(viewport.getNearestPanel()!);\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n\n    transitTo(STATE_TYPE.IDLE);\n    viewport.updateCameraPosition();\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted, {\n      direction: this.direction,\n    });\n  }\n}\n\nexport default AnimatingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport type { OnAnimationEnd, OnChange, OnRelease } from \"@egjs/axes\";\nimport State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: OnAnimationEnd, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(e: OnChange, { viewport, transitTo }: FlickingContext): void {\n    // Can stop Axes's change event\n    e.stop();\n\n    // Should update axes position as it's already changed at this moment\n    viewport.updateAxesPosition(viewport.getCameraPosition());\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: OnRelease, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { MoveTypeStringOption, MoveTypeContext, DestinationInfo } from \"../types\";\nimport Panel from \"../components/Panel\";\nimport { EVENTS } from \"../consts\";\n\nabstract class MoveType {\n  protected readonly abstract type: string;\n\n  public abstract findTargetPanel(ctx: MoveTypeContext): DestinationInfo;\n\n  public is(type: MoveTypeStringOption): boolean {\n    return type === this.type;\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    const viewport = ctx.viewport;\n    const options = viewport.options;\n\n    const panel = options.circular\n      ? this.findRestorePanelInCircularMode(ctx)\n      : viewport.getCurrentPanel()!;\n\n    return {\n      panel,\n      destPos: viewport.findEstimatedPosition(panel),\n      duration: options.duration,\n      eventType: EVENTS.RESTORE,\n    };\n  }\n\n  public findPanelWhenInterrupted(ctx: MoveTypeContext): DestinationInfo {\n    const { state, viewport } = ctx;\n    const targetPanel = state.targetPanel!;\n\n    return {\n      panel: targetPanel,\n      destPos: viewport.findEstimatedPosition(targetPanel),\n      duration: viewport.options.duration,\n      eventType: \"\",\n    };\n  }\n\n  // Calculate minimum distance to \"change\" panel\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const relativeAnchorPosition = currentPanel.getRelativeAnchorPosition();\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |--------|--------------|\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\n     */\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanel.getSize() - relativeAnchorPosition + halfGap\n      : relativeAnchorPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n\n  private findRestorePanelInCircularMode(ctx: MoveTypeContext): Panel {\n    const viewport = ctx.viewport;\n    const originalPanel = viewport.getCurrentPanel()!.getOriginalPanel();\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = originalPanel.getIdenticalPanels()[1];\n    const lapped = Math.abs(originalPanel.getAnchorPosition() - hangerPosition)\n      > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n    return (!ctx.isNextDirection && lapped)\n      ? firstClonedPanel\n      : originalPanel;\n  }\n}\n\nexport default MoveType;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport MoveType from \"./MoveType\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { clamp } from \"../utils\";\n\nclass Snap extends MoveType {\n  protected readonly type: string = MOVE_TYPE.SNAP;\n  protected count: number;\n\n  constructor(count: number) {\n    super();\n    this.count = count;\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, axesEvent, swipeDistance } = ctx;\n    const snapCount = this.count;\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    const currentPanel = viewport.getCurrentPanel()!;\n    const nearestPanel = viewport.getNearestPanel()!;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    const nearestIsCurrent = nearestPanel.getIndex() === currentPanel.getIndex();\n\n    // This can happen when bounce is 0\n    const shouldMoveWhenBounceIs0 = viewport.canSetBoundMode() && nearestIsCurrent;\n    const shouldMoveToAdjacent = !viewport.isOutOfBound()\n      && (swipeDistance <= minimumDistanceToChange || shouldMoveWhenBounceIs0);\n\n    if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n      return this.findSnappedPanel(ctx);\n    } else if (shouldMoveToAdjacent) {\n      return this.findAdjacentPanel(ctx);\n    } else {\n      return {\n        panel: nearestPanel,\n        duration: viewport.options.duration,\n        destPos: viewport.findEstimatedPosition(nearestPanel),\n        // As swipeDistance holds mouse/touch position change regardless of bounce option value\n        // swipDistance > minimumDistanceToChange can happen in bounce area\n        // Second condition is for handling that.\n        eventType: (swipeDistance <= minimumDistanceToChange)\n          || (viewport.isOutOfBound() && nearestIsCurrent)\n          ? EVENTS.RESTORE\n          : EVENTS.CHANGE,\n      };\n    }\n  }\n\n  protected findSnappedPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, state, isNextDirection } = ctx;\n\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    const snapCount = this.count;\n    const options = viewport.options;\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const halfGap = options.gap / 2;\n    const estimatedHangerPos = axesEvent.destPos.flick + viewport.getRelativeHangerPosition();\n\n    let panelToMove = viewport.getNearestPanel()!;\n    let cycleIndex = panelToMove.getCloneIndex() + 1; // 0(original) or 1(clone)\n    let passedPanelCount = 0;\n\n    while (passedPanelCount < snapCount) {\n      // Since panelToMove holds also cloned panels, we should use original panel's position\n      const originalPanel = panelToMove.getOriginalPanel();\n      const panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      const panelSize = originalPanel.getSize();\n\n      const panelNextPosition = panelPosition + panelSize + halfGap;\n      const panelPrevPosition = panelPosition - halfGap;\n\n      // Current panelToMove contains destPos\n      if (\n        (isNextDirection && panelNextPosition > estimatedHangerPos)\n        || (!isNextDirection && panelPrevPosition < estimatedHangerPos)\n      ) {\n        break;\n      }\n\n      const siblingPanel = isNextDirection\n        ? panelToMove.nextSibling\n        : panelToMove.prevSibling;\n      if (!siblingPanel) {\n        break;\n      }\n\n      const panelIndex = panelToMove.getIndex();\n      const siblingIndex = siblingPanel.getIndex();\n      if ((isNextDirection && siblingIndex <= panelIndex)\n        || (!isNextDirection && siblingIndex >= panelIndex)\n      ) {\n        cycleIndex = isNextDirection\n          ? cycleIndex + 1\n          : cycleIndex - 1;\n      }\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n    }\n\n    const originalPosition = panelToMove.getOriginalPanel().getPosition();\n\n    if (cycleIndex !== 0) {\n      panelToMove = panelToMove.clone(panelToMove.getCloneIndex(), true);\n      panelToMove.setPosition(originalPosition + cycleIndex * scrollAreaSize);\n    }\n\n    const defaultDuration = viewport.options.duration;\n    const duration = clamp(axesEvent.duration, defaultDuration, defaultDuration * passedPanelCount);\n\n    return {\n      panel: panelToMove,\n      destPos: viewport.findEstimatedPosition(panelToMove),\n      duration,\n      eventType: Math.max(eventDelta, state.delta) > minimumDistanceToChange\n        ? EVENTS.CHANGE\n        : EVENTS.RESTORE,\n    };\n  }\n\n  private findAdjacentPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentIndex = viewport.getCurrentIndex();\n    const currentPanel = viewport.panelManager.get(currentIndex)!;\n    const hangerPosition = viewport.getHangerPosition();\n    const scrollArea = viewport.getScrollArea();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = options.circular\n      && (Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition));\n\n    // If lapped in circular mode, use first cloned panel as base panel\n    const basePanel = lapped\n      ? firstClonedPanel\n      : currentPanel;\n    const basePosition = basePanel.getPosition();\n\n    const adjacentPanel = isNextDirection\n      ? basePanel.nextSibling\n      : basePanel.prevSibling;\n\n    const eventType = adjacentPanel\n      ? EVENTS.CHANGE\n      : EVENTS.RESTORE;\n    const panelToMove = adjacentPanel\n      ? adjacentPanel\n      : basePanel;\n    const targetRelativeAnchorPosition = panelToMove.getRelativeAnchorPosition();\n\n    const estimatedPanelPosition = options.circular\n      ? isNextDirection\n        ? basePosition + basePanel.getSize() + targetRelativeAnchorPosition + options.gap\n        : basePosition - (panelToMove.getSize() - targetRelativeAnchorPosition) - options.gap\n      : panelToMove.getAnchorPosition();\n    const estimatedPosition = estimatedPanelPosition - viewport.getRelativeHangerPosition();\n    const destPos = viewport.canSetBoundMode()\n      ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next)\n      : estimatedPosition;\n\n    return {\n      panel: panelToMove,\n      destPos,\n      duration: options.duration,\n      eventType,\n    };\n  }\n}\n\nexport default Snap;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Snap from \"./Snap\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { circulate, clamp } from \"../utils\";\n\nclass FreeScroll extends Snap {\n  protected readonly type: string = MOVE_TYPE.FREE_SCROLL;\n\n  constructor() {\n    // Set snap count to Infinity\n    super(Infinity);\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, state, viewport } = ctx;\n    const destPos = axesEvent.destPos.flick;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    const scrollArea = viewport.getScrollArea();\n    const currentPanel = viewport.getCurrentPanel()!;\n    const options = viewport.options;\n\n    const delta = Math.abs(axesEvent.delta.flick + state.delta);\n    if (delta > minimumDistanceToChange) {\n      const destInfo = super.findSnappedPanel(ctx);\n\n      destInfo.duration = axesEvent.duration;\n      destInfo.destPos = destPos;\n      destInfo.eventType = !options.circular && destInfo.panel === currentPanel\n        ? \"\"\n        : EVENTS.CHANGE;\n\n      return destInfo;\n    } else {\n      let estimatedPosition = options.circular\n        ? circulate(destPos, scrollArea.prev, scrollArea.next, false)\n        : destPos;\n      estimatedPosition = clamp(estimatedPosition, scrollArea.prev, scrollArea.next);\n      estimatedPosition += viewport.getRelativeHangerPosition();\n\n      const estimatedPanel = viewport.findNearestPanelAt(estimatedPosition)!;\n\n      return {\n        panel: estimatedPanel,\n        destPos,\n        duration: axesEvent.duration,\n        eventType: \"\",\n      };\n    }\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    return this.findTargetPanel(ctx);\n  }\n\n  public findPanelWhenInterrupted(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport } = ctx;\n\n    return {\n      panel: viewport.getNearestPanel()!,\n      destPos: viewport.getCameraPosition(),\n      duration: 0,\n      eventType: \"\",\n    };\n  }\n\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const lastPosition = viewport.stateMachine.getState().lastPosition;\n    const currentPanelPosition = currentPanel.getPosition();\n\n    // As camera can stop anywhere in free scroll mode,\n    // minimumDistanceToChange should be calculated differently.\n    // Ref #191(https://github.com/naver/egjs-flicking/issues/191)\n    const lastHangerPosition = lastPosition + viewport.getRelativeHangerPosition();\n\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanelPosition + currentPanel.getSize() - lastHangerPosition + halfGap\n      : lastHangerPosition - currentPanelPosition + halfGap;\n    minimumDistanceToChange = Math.abs(minimumDistanceToChange % scrollAreaSize);\n\n    return Math.min(minimumDistanceToChange, scrollAreaSize - minimumDistanceToChange);\n  }\n}\n\nexport default FreeScroll;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Axes, { PanInput } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport Panel from \"./Panel\";\nimport PanelManager from \"./PanelManager\";\nimport StateMachine from \"./StateMachine\";\nimport MoveType from \"../moves/MoveType\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus, ElementLike, EventType, TriggerCallback, NeedPanelEvent, FlickingEvent, MoveTypeObjectOption, OriginalStyle, Plugin, DestroyOption, BoundingBox } from \"../types\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS, EVENTS, DIRECTION, STATE_TYPE, MOVE_TYPE } from \"../consts\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray, parseElement, hasClass, restoreStyle, circulate, findIndex, getBbox } from \"../utils\";\nimport Snap from \"../moves/Snap\";\nimport FreeScroll from \"../moves/FreeScroll\";\n\nexport default class Viewport {\n  public options: FlickingOptions;\n  public stateMachine: StateMachine;\n  public panelManager: PanelManager;\n  public moveType: MoveType;\n\n  private flicking: Flicking;\n  private axes: Axes;\n  private panInput: PanInput | null;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private triggerEvent: Flicking[\"triggerEvent\"];\n  private axesHandlers: { [key: string]: any };\n\n  private currentPanel: Panel | undefined;\n  private nearestPanel: Panel | undefined;\n  private visiblePanels: Panel[];\n\n  private plugins: Plugin[] = [];\n  private panelBboxes: { [className: string]: BoundingBox };\n  private state: {\n    size: number;\n    position: number;\n    panelMaintainRatio: number;\n    relativeHangerPosition: number;\n    positionOffset: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    infiniteThreshold: number;\n    checkedIndexes: Array<[number, number]>;\n    isAdaptiveCached: boolean;\n    isViewportGiven: boolean;\n    isCameraGiven: boolean;\n    originalViewportStyle: OriginalStyle;\n    originalCameraStyle: OriginalStyle;\n    cachedBbox: BoundingBox | null;\n  };\n\n  constructor(\n    flicking: Flicking,\n    options: FlickingOptions,\n    triggerEvent: Flicking[\"triggerEvent\"],\n  ) {\n    this.flicking = flicking;\n    this.triggerEvent = triggerEvent;\n\n    this.state = {\n      size: 0,\n      position: 0,\n      panelMaintainRatio: 0,\n      relativeHangerPosition: 0,\n      positionOffset: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n      isAdaptiveCached: false,\n      isViewportGiven: false,\n      isCameraGiven: false,\n      originalViewportStyle: {\n        className: null,\n        style: null,\n      },\n      originalCameraStyle: {\n        className: null,\n        style: null,\n      },\n      cachedBbox: null,\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n    this.visiblePanels = [];\n    this.panelBboxes = {};\n\n    this.build();\n  }\n\n  public moveTo(\n    panel: Panel,\n    destPos: number,\n    eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | \"\",\n    axesEvent: any,\n    duration: number = this.options.duration,\n  ): TriggerCallback {\n    const state = this.state;\n    const currentState = this.stateMachine.getState();\n    const currentPosition = state.position;\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const direction = destPos === currentPosition\n      ? null\n      : destPos > currentPosition\n        ? DIRECTION.NEXT\n        : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel,\n        direction,\n      });\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      currentState.delta = 0;\n      currentState.lastPosition = this.getCameraPosition();\n      currentState.targetPanel = panel;\n      currentState.direction = destPos === currentPosition\n        ? null\n        : destPos > currentPosition\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      if (destPos === currentPosition) {\n        // no move\n        this.nearestPanel = panel;\n        this.currentPanel = panel;\n      }\n\n      if (axesEvent && axesEvent.setTo) {\n        // freeScroll only occurs in release events\n        axesEvent.setTo({ flick: destPos }, duration);\n      } else {\n        this.axes.setTo({ flick: destPos }, duration);\n      }\n    });\n\n    return eventResult;\n  }\n\n  public moveCamera(pos: number, axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const transform = state.translate.name;\n    const scrollArea = state.scrollArea;\n\n    // Update position & nearestPanel\n    if (options.circular && !isBetween(pos, scrollArea.prev, scrollArea.next)) {\n      pos = circulate(pos, scrollArea.prev, scrollArea.next, false);\n    }\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n    const nearestPanel = this.nearestPanel;\n    const originalNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    // From 0(panel position) to 1(panel position + panel size)\n    // When it's on gap area value will be (val > 1 || val < 0)\n    if (nearestPanel) {\n      const hangerPosition = this.getHangerPosition();\n      const panelPosition = nearestPanel.getPosition();\n      const panelSize = nearestPanel.getSize();\n      const halfGap = options.gap / 2;\n\n      // As panel's range is from panel position - half gap ~ panel pos + panel size + half gap\n      state.panelMaintainRatio = (hangerPosition - panelPosition + halfGap) / (panelSize + 2 * halfGap);\n    } else {\n      state.panelMaintainRatio = 0;\n    }\n\n    this.checkNeedPanel(axesEvent);\n\n    // Possibly modified after need panel, if it's looped\n    const modifiedNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    pos += (modifiedNearestPosition - originalNearestPosition);\n    state.position = pos;\n\n    this.updateVisiblePanels();\n\n    // Offset is needed to fix camera layer size in visible-only rendering mode\n    const posOffset = options.renderOnlyVisible\n      ? state.positionOffset\n      : 0;\n    const moveVector = options.horizontal\n      ? [-(pos - posOffset), 0] : [0, -(pos - posOffset)];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n  }\n\n  public stopCamera = (axesEvent: any): void => {\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: this.state.position }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  public unCacheBbox(): void {\n    const state = this.state;\n    const options = this.options;\n\n    state.cachedBbox = null;\n    this.visiblePanels = [];\n\n    const viewportElement = this.viewportElement;\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n    } else {\n      viewportElement.style.height = \"\";\n    }\n    state.isAdaptiveCached = false;\n    this.panelBboxes = {};\n  }\n\n  public resize(): void {\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n    this.updateClonePanels();\n    this.updateVisiblePanelPositions();\n    this.updateCameraPosition();\n    this.updatePlugins();\n  }\n\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const hangerPosition = this.getHangerPosition();\n\n    if (this.isOutOfBound()) {\n      const position = state.position;\n\n      return position <= state.scrollArea.prev\n        ? panelManager.firstPanel()\n        : panelManager.lastPanel();\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  }\n\n  public findNearestPanelAt(position: number): Panel | undefined {\n    const panelManager = this.panelManager;\n\n    const allPanels = panelManager.allPanels();\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel | undefined;\n\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(position, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - position),\n          Math.abs(nextPosition - position),\n        );\n\n      if (distance > minimumDistance) {\n        break;\n      } else if (distance === minimumDistance) {\n        const minimumAnchorDistance = Math.abs(position - nearestPanel!.getAnchorPosition());\n        const anchorDistance = Math.abs(position - panel.getAnchorPosition());\n\n        if (anchorDistance > minimumAnchorDistance) {\n          break;\n        }\n      }\n\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = this.getHangerPosition();\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = this.getHangerPosition();\n    const distance = Math.abs(hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.relativeHangerPosition\n        : anchorPosition > hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.relativeHangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  }\n\n  public findEstimatedPosition(panel: Panel): number {\n    const scrollArea = this.getScrollArea();\n\n    let estimatedPosition = panel.getAnchorPosition() - this.getRelativeHangerPosition();\n    estimatedPosition = this.canSetBoundMode()\n      ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next)\n      : estimatedPosition;\n\n    return estimatedPosition;\n  }\n\n  public addVisiblePanel(panel: Panel): void {\n    if (this.getVisibleIndexOf(panel) < 0) {\n      this.visiblePanels.push(panel);\n    }\n  }\n\n  public enable(): void {\n    if (!this.panInput) {\n      this.createPanInput();\n    }\n  }\n\n  public disable(): void {\n    if (this.panInput) {\n      this.panInput.destroy();\n      this.panInput = null;\n\n      // Refresh Axes instance\n      this.axes.destroy();\n      this.setAxesInstance();\n      this.updateScrollArea();\n      this.updateAxesPosition(this.state.position);\n\n      this.stateMachine.transitTo(STATE_TYPE.IDLE);\n    }\n  }\n\n  public insert(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const lastIndex = this.panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const options = this.options;\n    const parsedElements = parseElement(element);\n\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const pushedIndex = this.panelManager.insert(index, panels);\n\n    // ...then calc bbox for all panels\n    this.resizePanels(panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n      this.nearestPanel = panels[0];\n\n      const newCenterPanel = panels[0];\n      const newPanelPosition = this.findEstimatedPosition(newCenterPanel);\n      state.position = newPanelPosition;\n      this.updateAxesPosition(newPanelPosition);\n      state.panelMaintainRatio = (newCenterPanel.getRelativeAnchorPosition() + options.gap / 2) / (newCenterPanel.getSize() + options.gap);\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index });\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n\n    this.resize();\n\n    return panels;\n  }\n\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const lastIndex = panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const parsedElements = parseElement(element);\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const replacedPanels = panelManager.replace(index, panels);\n\n    replacedPanels.forEach(panel => {\n      const visibleIndex = this.getVisibleIndexOf(panel);\n      if (visibleIndex > -1) {\n        this.visiblePanels.splice(visibleIndex, 1);\n      }\n    });\n\n    // ...then calc bbox for all panels\n    this.resizePanels(panels);\n\n    const currentPanel = this.currentPanel;\n    const wasEmpty = !currentPanel;\n    if (wasEmpty) {\n      this.currentPanel = panels[0];\n      this.nearestPanel = panels[0];\n\n      const newCenterPanel = panels[0];\n      const newPanelPosition = this.findEstimatedPosition(newCenterPanel);\n      state.position = newPanelPosition;\n      this.updateAxesPosition(newPanelPosition);\n      state.panelMaintainRatio = (newCenterPanel.getRelativeAnchorPosition() + options.gap / 2) / (newCenterPanel.getSize() + options.gap);\n    } else if (isBetween(currentPanel!.getIndex(), index, index + panels.length - 1)) {\n      // Current panel is replaced\n      this.currentPanel = panelManager.get(currentPanel!.getIndex());\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index + panels.length - 1 });\n\n    this.resize();\n\n    return panels;\n  }\n\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    const state = this.state;\n    // Index should not below 0\n    index = Math.max(index, 0);\n\n    const panelManager = this.panelManager;\n    const currentIndex = this.getCurrentIndex();\n\n    const removedPanels = panelManager.remove(index, deleteCount);\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      const newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    }\n\n    // Update checked indexes in infinite mode\n    if (deleteCount > 0) {\n      // Check whether removing index will affect checked indexes\n      // Suppose index 0 is empty and removed index 1, then checked index 0 should be deleted and vice versa.\n      this.updateCheckedIndexes({ min: index - 1, max: index + deleteCount });\n      // Uncache visible panels to refresh panels\n      this.visiblePanels = [];\n    }\n\n    if (panelManager.getPanelCount() <= 0) {\n      this.currentPanel = undefined;\n      this.nearestPanel = undefined;\n    }\n\n    this.resize();\n\n    const scrollArea = state.scrollArea;\n    if (state.position < scrollArea.prev || state.position > scrollArea.next) {\n      const newPosition = circulate(state.position, scrollArea.prev, scrollArea.next, false);\n      this.moveCamera(newPosition);\n      this.updateAxesPosition(newPosition);\n    }\n\n    return removedPanels;\n  }\n\n  public updateAdaptiveSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const horizontal = options.horizontal;\n    const currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    const shouldApplyAdaptive = options.adaptive || !state.isAdaptiveCached;\n    const viewportStyle = this.viewportElement.style;\n    if (shouldApplyAdaptive) {\n      let sizeToApply: number;\n      if (options.adaptive) {\n        const panelBbox = currentPanel.getBbox();\n\n        sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n      } else {\n        // Find minimum height of panels to maximum panel size\n        const maximumPanelSize = this.panelManager.originalPanels().reduce((maximum, panel) => {\n          const panelBbox = panel.getBbox();\n          return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n        }, 0);\n\n        sizeToApply = maximumPanelSize;\n      }\n\n      if (!state.isAdaptiveCached) {\n        const viewportBbox = this.updateBbox();\n        sizeToApply = Math.max(sizeToApply, horizontal ? viewportBbox.height : viewportBbox.width);\n        state.isAdaptiveCached = true;\n      }\n\n      const viewportSize = `${sizeToApply}px`;\n      if (horizontal) {\n        viewportStyle.height = viewportSize;\n        state.cachedBbox!.height = sizeToApply;\n      } else {\n        viewportStyle.width = viewportSize;\n        state.cachedBbox!.width = sizeToApply;\n      }\n    }\n  }\n\n  // Update camera position after resizing\n  public updateCameraPosition(): void {\n    const state = this.state;\n    const currentPanel = this.getCurrentPanel();\n    const cameraPosition = this.getCameraPosition();\n    const currentState = this.stateMachine.getState();\n    const isFreeScroll = this.moveType.is(MOVE_TYPE.FREE_SCROLL);\n    const relativeHangerPosition = this.getRelativeHangerPosition();\n    const halfGap = this.options.gap / 2;\n\n    if (currentState.holding || currentState.playing) {\n      this.updateVisiblePanels();\n      return;\n    }\n\n    let newPosition: number;\n    if (isFreeScroll) {\n      const positionBounded = this.canSetBoundMode() && (cameraPosition === state.scrollArea.prev || cameraPosition === state.scrollArea.next);\n      const nearestPanel = this.getNearestPanel();\n\n      // Preserve camera position if it is bound to scroll area limit\n      newPosition = positionBounded || !nearestPanel\n        ? cameraPosition\n        : nearestPanel.getPosition() - halfGap + (nearestPanel.getSize() + 2 * halfGap) * state.panelMaintainRatio - relativeHangerPosition;\n    } else {\n      newPosition = currentPanel\n        ? currentPanel.getAnchorPosition() - relativeHangerPosition\n        : cameraPosition;\n    }\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n    this.updateAxesPosition(newPosition);\n\n    this.moveCamera(newPosition);\n  }\n\n  public updateBbox(): BoundingBox {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n\n    if (!state.cachedBbox) {\n      state.cachedBbox = getBbox(viewportElement, options.useOffset);\n    }\n\n    return state.cachedBbox!;\n  }\n\n  public updatePlugins(): void {\n    // update for resize\n    this.plugins.forEach(plugin => {\n      plugin.update && plugin.update(this.flicking);\n    });\n  }\n\n  public destroy(option: Partial<DestroyOption>): void {\n    const state = this.state;\n    const wrapper = this.flicking.getElement();\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const originalPanels = this.panelManager.originalPanels();\n\n    this.removePlugins(this.plugins);\n    if (!option.preserveUI) {\n      restoreStyle(viewportElement, state.originalViewportStyle);\n      restoreStyle(cameraElement, state.originalCameraStyle);\n\n      if (!state.isCameraGiven && !this.options.renderExternal) {\n        const topmostElement = state.isViewportGiven\n          ? viewportElement\n          : wrapper;\n        const deletingElement = state.isViewportGiven\n          ? cameraElement\n          : viewportElement;\n\n        originalPanels.forEach(panel => {\n          topmostElement.appendChild(panel.getElement());\n        });\n\n        topmostElement.removeChild(deletingElement);\n      }\n    }\n\n    this.axes.destroy();\n    this.panInput?.destroy();\n\n    originalPanels.forEach(panel => { panel.destroy(option); });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const defaultIndex = this.options.defaultIndex;\n    const cameraElement = this.cameraElement;\n    const panelManager = this.panelManager;\n\n    // Restore index\n    cameraElement.innerHTML = panels.map(panel => panel.html).join(\"\");\n\n    // Create panels first\n    this.refreshPanels();\n    const createdPanels = panelManager.originalPanels();\n\n    // ...then order it by its index\n    const orderedPanels: Panel[] = [];\n    panels.forEach((panel, idx) => {\n      const createdPanel = createdPanels[idx];\n      createdPanel.setIndex(panel.index);\n      createdPanel.setPosition(panel.position);\n      orderedPanels[panel.index] = createdPanel;\n    });\n    panelManager.replacePanels(orderedPanels, []);\n    panelManager.setCloneCount(0); // No clones at this point\n\n    const panelCount = panelManager.getPanelCount();\n    if (panelCount > 0) {\n      this.currentPanel = panelManager.get(status.index)\n        || panelManager.get(defaultIndex)\n        || panelManager.firstPanel();\n    } else {\n      this.currentPanel = undefined;\n    }\n    this.visiblePanels = orderedPanels.filter(panel => Boolean(panel));\n\n    this.resize();\n\n    this.axes.setTo({ flick: status.position }, 0);\n    this.moveCamera(status.position);\n  }\n\n  public calcVisiblePanels(): Panel[] {\n    const allPanels = this.panelManager.allPanels();\n    if (this.options.renderOnlyVisible) {\n      const cameraPos = this.getCameraPosition();\n      const viewportSize = this.getSize();\n      const basePanel = this.nearestPanel!;\n\n      const getNextPanel = (panel: Panel) => {\n        const nextPanel = panel.nextSibling;\n\n        if (nextPanel && nextPanel.getPosition() >= panel.getPosition()) {\n          return nextPanel;\n        } else {\n          return null;\n        }\n      };\n\n      const getPrevPanel = (panel: Panel) => {\n        const prevPanel = panel.prevSibling;\n\n        if (prevPanel && prevPanel.getPosition() <= panel.getPosition()) {\n          return prevPanel;\n        } else {\n          return null;\n        }\n      };\n\n      const isOutOfBoundNext = (panel: Panel) => panel.getPosition() >= cameraPos + viewportSize;\n      const isOutOfBoundPrev = (panel: Panel) => panel.getPosition() + panel.getSize() <= cameraPos;\n\n      const getVisiblePanels = (\n        panel: Panel,\n        getNext: (panel: Panel) => Panel | null,\n        isOutOfViewport: (panel: Panel) => boolean,\n      ): Panel[] => {\n        const visiblePanels: Panel[] = [];\n\n        let lastPanel = panel;\n        while (true) {\n          const nextPanel = getNext(lastPanel);\n          if (!nextPanel || isOutOfViewport(nextPanel)) {\n            break;\n          }\n          visiblePanels.push(nextPanel);\n          lastPanel = nextPanel;\n        }\n        return visiblePanels;\n      };\n\n      const panelCount = this.panelManager.getPanelCount();\n      const getAbsIndex = (panel: Panel) => panel.getIndex() + (panel.getCloneIndex() + 1) * panelCount;\n      const nextPanels = getVisiblePanels(basePanel, getNextPanel, isOutOfBoundNext);\n      const prevPanels = getVisiblePanels(basePanel, getPrevPanel, isOutOfBoundPrev);\n\n      return [basePanel, ...nextPanels, ...prevPanels].sort((panel1, panel2) => getAbsIndex(panel1) - getAbsIndex(panel2));\n    } else {\n      return allPanels.filter(panel => {\n        const outsetProgress = panel.getOutsetProgress();\n\n        return outsetProgress > -1 && outsetProgress < 1;\n      });\n    }\n  }\n\n  public getCurrentPanel(): Panel | undefined {\n    return this.currentPanel;\n  }\n\n  public getCurrentIndex(): number {\n    const currentPanel = this.currentPanel;\n\n    return currentPanel\n      ? currentPanel.getIndex()\n      : -1;\n  }\n\n  public getNearestPanel(): Panel | undefined {\n    return this.nearestPanel;\n  }\n\n  // Get progress from nearest panel\n  public getCurrentProgress(): number {\n    const currentState = this.stateMachine.getState();\n    let nearestPanel = currentState.playing || currentState.holding\n      ? this.nearestPanel\n      : this.currentPanel;\n\n    const panelManager = this.panelManager;\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n    const { prev: prevRange, next: nextRange } = this.getScrollArea();\n    const cameraPosition = this.getCameraPosition();\n    const isOutOfBound = this.isOutOfBound();\n    let prevPanel = nearestPanel.prevSibling;\n    let nextPanel = nearestPanel.nextSibling;\n    let hangerPosition = this.getHangerPosition();\n    let nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (\n      isOutOfBound\n      && prevPanel\n      && nextPanel\n      && cameraPosition < nextRange\n      // On the basis of anchor, prevPanel is nearestPanel.\n      && (hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition)\n    ) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n    const nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    const nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      const relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n    const hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    const gap = this.options.gap;\n\n    let basePosition = nearestAnchorPos;\n    let targetPosition = nearestAnchorPos;\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel\n        ? nextPanel.getAnchorPosition()\n        : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel\n        ? prevPanel.getAnchorPosition()\n        : nearestAnchorPos - nearestSize - gap;\n    }\n\n    const progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    const startIndex = hangerIsNextToNearestPanel\n      ? nearestIndex\n      : prevPanel\n        ? prevPanel.getIndex()\n        : nearestIndex - 1;\n\n    return startIndex + progressBetween;\n  }\n\n  // Update axes flick position without triggering event\n  public updateAxesPosition(position: number) {\n    const axes = this.axes;\n    axes.off();\n    axes.setTo({\n      flick: position,\n    }, 0);\n    axes.on(this.axesHandlers);\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n\n  public isOutOfBound(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const scrollArea = state.scrollArea;\n\n    return !options.circular\n      && options.bound\n      && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  }\n\n  public canSetBoundMode(): boolean {\n    const options = this.options;\n\n    return options.bound && !options.circular;\n  }\n\n  public getViewportElement(): HTMLElement {\n    return this.viewportElement;\n  }\n\n  public getCameraElement(): HTMLElement {\n    return this.cameraElement;\n  }\n\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getRelativeHangerPosition(): number {\n    return this.state.relativeHangerPosition;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.position + this.state.relativeHangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public getPositionOffset(): number {\n    return this.state.positionOffset;\n  }\n\n  public getCheckedIndexes(): Array<[number, number]> {\n    return this.state.checkedIndexes;\n  }\n\n  public getVisiblePanels(): Panel[] {\n    return this.visiblePanels;\n  }\n\n  public setCurrentPanel(panel: Panel | undefined): void {\n    this.currentPanel = panel;\n  }\n\n  public setLastIndex(index: number): void {\n    const currentPanel = this.currentPanel;\n    const panelManager = this.panelManager;\n\n    panelManager.setLastIndex(index);\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  }\n\n  public setVisiblePanels(panels: Panel[]): void {\n    this.visiblePanels = panels;\n  }\n\n  public connectAxesHandler(handlers: { [key: string]: (event: { [key: string]: any; }) => any }): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  }\n\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this.flicking);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(this.flicking);\n    });\n    return this;\n  }\n\n  public updateCheckedIndexes(changedRange: { min: number, max: number }): void {\n    const state = this.state;\n\n    let removed = 0;\n    state.checkedIndexes.concat().forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (changedRange.min <= max && changedRange.max >= min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx - removed, 1);\n        removed++;\n      }\n    });\n  }\n\n  public appendUncachedPanelElements(panels: Panel[]): void {\n    const options = this.options;\n    const fragment = document.createDocumentFragment();\n\n    if (options.isEqualSize) {\n      const prevVisiblePanels = this.visiblePanels;\n      const equalSizeClasses = options.isEqualSize as string[]; // for readability\n      const cached: { [className: string]: boolean } = {};\n\n      this.visiblePanels = [];\n\n      Object.keys(this.panelBboxes).forEach(className => {\n        cached[className] = true;\n      });\n\n      panels.forEach(panel => {\n        const overlappedClass = panel.getOverlappedClass(equalSizeClasses);\n        if (overlappedClass && !cached[overlappedClass]) {\n          if (!options.renderExternal) {\n            fragment.appendChild(panel.getElement());\n          }\n          this.visiblePanels.push(panel);\n          cached[overlappedClass] = true;\n        } else if (!overlappedClass) {\n          if (!options.renderExternal) {\n            fragment.appendChild(panel.getElement());\n          }\n          this.visiblePanels.push(panel);\n        }\n      });\n      prevVisiblePanels.forEach(panel => {\n        this.addVisiblePanel(panel);\n      });\n    } else {\n      if (!options.renderExternal) {\n        panels.forEach(panel => fragment.appendChild(panel.getElement()));\n      }\n      this.visiblePanels = panels.filter(panel => Boolean(panel));\n    }\n\n    if (!options.renderExternal) {\n      this.cameraElement.appendChild(fragment);\n    }\n  }\n\n  private updateClonePanels() {\n    const panelManager = this.panelManager;\n\n    // Clone panels in circular mode\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n    panelManager.chainAllPanels();\n  }\n\n  private getVisibleIndexOf(panel: Panel): number {\n    return findIndex(this.visiblePanels, visiblePanel => visiblePanel === panel);\n  }\n\n  private build(): void {\n    this.setElements();\n    this.applyCSSValue();\n    this.setMoveType();\n    this.setAxesInstance();\n    this.createPanInput();\n    this.refreshPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private setElements(): void {\n    const state = this.state;\n    const options = this.options;\n    const wrapper = this.flicking.getElement();\n    const classPrefix = options.classPrefix;\n\n    const viewportCandidate = wrapper.children[0] as HTMLElement;\n    const hasViewportElement = viewportCandidate && hasClass(viewportCandidate, `${classPrefix}-viewport`);\n\n    const viewportElement = hasViewportElement\n      ? viewportCandidate\n      : document.createElement(\"div\");\n\n    const cameraCandidate = hasViewportElement\n      ? viewportElement.children[0] as HTMLElement\n      : wrapper.children[0] as HTMLElement;\n    const hasCameraElement = cameraCandidate && hasClass(cameraCandidate, `${classPrefix}-camera`);\n\n    const cameraElement = hasCameraElement\n      ? cameraCandidate\n      : document.createElement(\"div\");\n\n    if (!hasCameraElement) {\n      cameraElement.className = `${classPrefix}-camera`;\n\n      const panelElements = hasViewportElement\n        ? viewportElement.children\n        : wrapper.children;\n\n      // Make all panels to be a child of camera element\n      // wrapper <- viewport <- camera <- panels[1...n]\n      toArray(panelElements).forEach(child => {\n        cameraElement.appendChild(child);\n      });\n    } else {\n      state.originalCameraStyle = {\n        className: cameraElement.getAttribute(\"class\"),\n        style: cameraElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasViewportElement) {\n      viewportElement.className = `${classPrefix}-viewport`;\n\n      // Add viewport element to wrapper\n      wrapper.appendChild(viewportElement);\n    } else {\n      state.originalViewportStyle = {\n        className: viewportElement.getAttribute(\"class\"),\n        style: viewportElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasCameraElement || !hasViewportElement) {\n      viewportElement.appendChild(cameraElement);\n    }\n\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    state.isViewportGiven = hasViewportElement;\n    state.isCameraGiven = hasCameraElement;\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const viewportStyle = this.viewportElement.style;\n\n    // Set default css values for each element\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    viewportElement.style.zIndex = `${options.zIndex}`;\n    if (options.horizontal) {\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n    if (options.overflow) {\n      viewportStyle.overflow = \"visible\";\n    }\n\n    this.panelManager = new PanelManager(this.cameraElement, options);\n  }\n\n  private setMoveType(): void {\n    const moveType = this.options.moveType as MoveTypeObjectOption;\n\n    switch (moveType.type) {\n      case MOVE_TYPE.SNAP:\n        this.moveType = new Snap(moveType.count);\n        break;\n      case MOVE_TYPE.FREE_SCROLL:\n        this.moveType = new FreeScroll();\n        break;\n      default:\n        throw new Error(\"moveType is not correct!\");\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n  }\n\n  private refreshPanels(): void {\n    const panelManager = this.panelManager;\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n\n    // Initialize panels\n    const panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this),\n    );\n\n    panelManager.replacePanels(panels, []);\n    this.visiblePanels = panels.filter(panel => Boolean(panel));\n  }\n\n  private setDefaultPanel(): void {\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const indexRange = this.panelManager.getRange();\n    const index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n\n    this.currentPanel = panelManager.get(index);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n\n    const gap = options.gap;\n    const viewportSize = state.size;\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    // There're no panels exist\n    if (!firstPanel) {\n      return;\n    }\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const panels = panelManager.originalPanels();\n    const reversedPanels = panels.concat().reverse();\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + gap;\n\n    if (sumOriginalPanelSize <= 0) {\n      return;\n    }\n\n    const relativeAnchorPosition = firstPanel.getRelativeAnchorPosition();\n    const relativeHangerPosition = this.getRelativeHangerPosition();\n\n    const areaPrev = (relativeHangerPosition - relativeAnchorPosition) % sumOriginalPanelSize;\n    let sizeSum = 0;\n    let panelAtLeftBoundary: Panel | null = null;\n    for (const panel of reversedPanels) {\n      if (!panel) {\n        continue;\n      }\n      sizeSum += panel.getSize() + gap;\n      if (sizeSum >= areaPrev) {\n        panelAtLeftBoundary = panel;\n        break;\n      }\n    }\n\n    const areaNext = (viewportSize - relativeHangerPosition + relativeAnchorPosition) % sumOriginalPanelSize;\n    sizeSum = 0;\n    let panelAtRightBoundary: Panel | null = null;\n    for (const panel of panels) {\n      if (!panel) {\n        continue;\n      }\n      sizeSum += panel.getSize() + gap;\n      if (sizeSum >= areaNext) {\n        panelAtRightBoundary = panel;\n        break;\n      }\n    }\n\n    // Need one more set of clones on prev area of original panel 0\n    const needCloneOnPrev = (panelAtLeftBoundary && panelAtRightBoundary)\n      && panelAtLeftBoundary.getIndex() !== 0\n      && panelAtLeftBoundary.getIndex() <= panelAtRightBoundary.getIndex();\n\n    // Visible count of panel 0 on first screen\n    const panel0OnFirstscreen = Math.ceil((relativeHangerPosition + firstPanel.getSize() - relativeAnchorPosition) / sumOriginalPanelSize)\n      + Math.ceil((viewportSize - relativeHangerPosition + relativeAnchorPosition) / sumOriginalPanelSize)\n      - 1; // duplication\n\n    const cloneCount = panel0OnFirstscreen\n      + (needCloneOnPrev ? 1 : 0);\n    const prevCloneCount = panelManager.getCloneCount();\n\n    panelManager.setCloneCount(cloneCount);\n    if (options.renderExternal) {\n      return;\n    }\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        const clones = panels.map(origPanel => origPanel.clone(cloneIndex));\n        const fragment = document.createDocumentFragment();\n        clones.forEach(panel => fragment.appendChild(panel.getElement()));\n\n        this.cameraElement.appendChild(fragment);\n        this.visiblePanels.push(...clones.filter(clone => Boolean(clone)));\n        panelManager.insertClones(cloneIndex, 0, clones);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const indexRange = this.panelManager.getRange();\n\n    const defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    const defaultPanel = panelManager.get(defaultIndex);\n\n    let defaultPosition = 0;\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode()\n        ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n        : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const panels = this.panelManager.originalPanels()\n      .filter(panel => Boolean(panel));\n    const bbox = this.updateBbox();\n\n    const prevSize = state.size;\n    // Update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    if (prevSize !== state.size) {\n      state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n      state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n    }\n\n    if (panels.length <= 0) {\n      return;\n    }\n\n    this.resizePanels(panels);\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panelManager = this.panelManager;\n\n    const firstPanel = panelManager.firstPanel();\n    const panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const currentPanel = this.currentPanel!;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n    const scrollArea = this.state.scrollArea;\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = firstPanel.getPosition();\n    let maintainingPanel: Panel = firstPanel;\n    if (nearestPanel) {\n      // We should maintain nearestPanel's position\n      const looped = !isBetween(currentState.lastPosition + currentState.delta, scrollArea.prev, scrollArea.next);\n\n      maintainingPanel = looped\n        ? currentPanel\n        : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    const panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    const accumulatedSize = panelsBeforeMaintainPanel.reduce((total, panel) => {\n      return total + panel.getSize() + gap;\n    }, 0);\n\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n\n    panels.forEach(panel => {\n      const newPosition = nextPanelPos;\n      const panelSize = panel.getSize();\n\n      panel.setPosition(newPosition);\n      nextPanelPos += panelSize + gap;\n    });\n\n    if (!this.options.renderOnlyVisible) {\n      panels.forEach(panel => panel.setPositionCSS());\n    }\n  }\n\n  private updateClonedPanelPositions(): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const clonedPanels = panelManager.clonedPanels()\n      .reduce((allClones, clones) => [...allClones, ...clones], [])\n      .filter(panel => Boolean(panel));\n\n    const scrollArea = state.scrollArea;\n\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      const origPanel = panel.getOriginalPanel();\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n\n    if (!this.options.renderOnlyVisible) {\n      clonedPanels.forEach(panel => {\n        panel.setPositionCSS();\n      });\n    }\n  }\n\n  private updateVisiblePanelPositions(): void {\n    if (this.options.renderOnlyVisible) {\n      this.visiblePanels.forEach(panel => {\n        panel.setPositionCSS(this.state.positionOffset);\n      });\n    }\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n    const relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0,\n      };\n    } else if (this.canSetBoundMode()) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition();\n\n      if (sumOriginalPanelSize >= state.size) {\n        state.scrollArea = {\n          prev: firstPanel.getPosition(),\n          next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n        };\n      } else {\n        // Find anchor position of set of the combined panels\n        const relAnchorPosOfCombined = parseArithmeticExpression(options.anchor, sumOriginalPanelSize);\n        const anchorPos = firstPanel.getPosition() + clamp(\n          relAnchorPosOfCombined,\n          sumOriginalPanelSize - (state.size - relativeHangerPosition),\n          relativeHangerPosition,\n        );\n\n        state.scrollArea = {\n          prev: anchorPos - relativeHangerPosition,\n          next: anchorPos - relativeHangerPosition,\n        };\n      }\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    const flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  }\n\n  private checkNeedPanel(axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentPanel = this.currentPanel;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    const gap = options.gap;\n    const infiniteThreshold = state.infiniteThreshold;\n    const maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent,\n        siblingPanel: null,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1,\n        },\n      });\n      return;\n    }\n\n    const originalNearestPosition = nearestPanel.getPosition();\n\n    // Check next direction\n    let checkingPanel: Panel | null = !currentState.holding && !currentState.playing\n      ? currentPanel\n      : nearestPanel;\n\n    while (checkingPanel) {\n      const currentIndex = checkingPanel.getIndex();\n      const nextSibling = checkingPanel.nextSibling;\n      const lastPanel = panelManager.lastPanel()!;\n      const atLastPanel = currentIndex === lastPanel.getIndex();\n      const nextIndex = !atLastPanel && nextSibling\n        ? nextSibling.getIndex()\n        : maxLastIndex + 1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      const cameraNext = state.position + state.size;\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = (nextIndex - currentIndex > 1);\n      // Expected prev panel's left position is smaller than camera position\n      const overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at max panel index\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        const firstPanel = panelManager.firstPanel();\n        const firstIndex = firstPanel\n          ? firstPanel.getIndex()\n          : -1;\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels are changed\n      const lastPanelAfterNeed = panelManager.lastPanel()!;\n      const atLastPanelAfterNeed = lastPanelAfterNeed && currentIndex === lastPanelAfterNeed.getIndex();\n\n      if (atLastPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    }\n\n    // Check prev direction\n    checkingPanel = nearestPanel;\n    while (checkingPanel) {\n      const cameraPrev = state.position;\n      const checkingIndex = checkingPanel.getIndex();\n      const prevSibling = checkingPanel.prevSibling;\n      const firstPanel = panelManager.firstPanel()!;\n      const atFirstPanel = checkingIndex === firstPanel.getIndex();\n      const prevIndex = !atFirstPanel && prevSibling\n        ? prevSibling.getIndex()\n        : -1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition);\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = checkingIndex - prevIndex > 1;\n      // Expected prev panel's right position is smaller than camera position\n      const overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at panel 0\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        const lastPanel = panelManager.lastPanel();\n\n        if (lastPanel && lastPanel.getIndex() < maxLastIndex) {\n          const lastIndex = lastPanel.getIndex();\n\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels were changed\n      const firstPanelAfterNeed = panelManager.firstPanel();\n      const atFirstPanelAfterNeed = firstPanelAfterNeed && checkingIndex === firstPanelAfterNeed.getIndex();\n\n      // Looped in circular mode\n      if (atFirstPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  }\n\n  private triggerNeedPanel(params: {\n    axesEvent: any;\n    siblingPanel: Panel | null,\n    direction: FlickingEvent[\"direction\"];\n    indexRange: NeedPanelEvent[\"range\"];\n  }): void {\n    const { axesEvent, siblingPanel, direction, indexRange } = params;\n    const options = this.options;\n    const checkedIndexes = this.state.checkedIndexes;\n    const alreadyTriggered = checkedIndexes.some(([min, max]) => min === indexRange.min || max === indexRange.max);\n    const hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    }\n\n    // Should done before triggering event, as we can directly add panels by event callback\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n\n    const index = siblingPanel\n      ? siblingPanel.getIndex()\n      : 0;\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n\n    this.triggerEvent(\n      EVENTS.NEED_PANEL,\n      axesEvent,\n      isTrusted,\n      {\n        index,\n        panel: siblingPanel,\n        direction,\n        range: indexRange,\n        fill: (element: ElementLike | ElementLike[]) => {\n          const panelManager = this.panelManager;\n          if (!siblingPanel) {\n            return this.insert(panelManager.getRange().max + 1, element);\n          }\n\n          const parsedElements = parseElement(element);\n          // Slice elements to fit size equal to empty spaces\n          const elements = direction === DIRECTION.NEXT\n            ? parsedElements.slice(0, indexRange.length)\n            : parsedElements.slice(-indexRange.length);\n\n          if (direction === DIRECTION.NEXT) {\n            if (options.circular && index === panelManager.getLastIndex()) {\n              // needPanel event is triggered on last index, insert at index 0\n              return this.insert(0, elements);\n            } else {\n              return siblingPanel.insertAfter(elements);\n            }\n          } else if (direction === DIRECTION.PREV) {\n            if (options.circular && index === 0) {\n              // needPanel event is triggered on first index(0), insert at the last index\n              return this.insert(indexRange.max - elements.length + 1, elements);\n            } else {\n              return siblingPanel.insertBefore(elements);\n            }\n          } else {\n            // direction is null when there're no panels exist\n            return this.insert(0, elements);\n          }\n        },\n      } as Partial<NeedPanelEvent>,\n    );\n  }\n\n  private updateVisiblePanels() {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentState = this.stateMachine.getState();\n    const cameraElement = this.cameraElement;\n    const { renderExternal, renderOnlyVisible } = options;\n    if (!renderOnlyVisible) {\n      return;\n    }\n\n    if (!this.nearestPanel) {\n      this.visiblePanels = [];\n      while (cameraElement.firstChild) {\n        cameraElement.removeChild(cameraElement.firstChild);\n      }\n      return;\n    }\n\n    const prevVisiblePanels = this.visiblePanels;\n    const newVisiblePanels = this.calcVisiblePanels();\n\n    const { addedPanels, removedPanels } = this.checkVisiblePanelChange(prevVisiblePanels, newVisiblePanels);\n\n    if (addedPanels.length <= 0 && removedPanels.length <= 0) {\n      // Visible panels not changed\n      return;\n    }\n\n    if (currentState.holding) {\n      newVisiblePanels.push(...removedPanels);\n    } else {\n      const firstVisiblePanelPos = newVisiblePanels[0].getPosition();\n      state.positionOffset = firstVisiblePanelPos;\n    }\n\n    newVisiblePanels.forEach(panel => {\n      panel.setPositionCSS(state.positionOffset);\n    });\n\n    if (!renderExternal) {\n      if (!currentState.holding) {\n        removedPanels.forEach(panel => {\n          const panelElement = panel.getElement();\n          panelElement.parentNode && cameraElement.removeChild(panelElement);\n        });\n      }\n\n      const fragment = document.createDocumentFragment();\n      addedPanels.forEach(panel => {\n        fragment.appendChild(panel.getElement());\n      });\n\n      cameraElement.appendChild(fragment);\n    }\n\n    const firstVisiblePanel = newVisiblePanels[0];\n    const lastVisiblePanel = newVisiblePanels[newVisiblePanels.length - 1];\n    const getAbsIndex = (panel: Panel) => panel.getIndex() + (panel.getCloneIndex() + 1) * panelManager.getPanelCount();\n\n    const newVisibleRange = {\n      min: getAbsIndex(firstVisiblePanel),\n      max: getAbsIndex(lastVisiblePanel),\n    };\n    this.visiblePanels = newVisiblePanels;\n    this.flicking.trigger(EVENTS.VISIBLE_CHANGE, {\n      type: EVENTS.VISIBLE_CHANGE,\n      range: newVisibleRange,\n    });\n  }\n\n  private checkVisiblePanelChange(prevVisiblePanels: Panel[], newVisiblePanels: Panel[]) {\n    const prevRefCount = prevVisiblePanels.map(() => 0);\n    const newRefCount = newVisiblePanels.map(() => 0);\n\n    prevVisiblePanels.forEach((prevPanel, prevIndex) => {\n      newVisiblePanels.forEach((newPanel, newIndex) => {\n        if (prevPanel === newPanel) {\n          prevRefCount[prevIndex]++;\n          newRefCount[newIndex]++;\n        }\n      });\n    });\n\n    const removedPanels = prevRefCount.reduce((removed: Panel[], count, index) => {\n      return count === 0\n        ? [...removed, prevVisiblePanels[index]]\n        : removed;\n    }, []);\n    const addedPanels = newRefCount.reduce((added: Panel[], count, index) => {\n      return count === 0\n        ? [...added, newVisiblePanels[index]]\n        : added;\n    }, []);\n\n    return { removedPanels, addedPanels };\n  }\n\n  private resizePanels(panels: Panel[]): void {\n    const options = this.options;\n    const panelBboxes = this.panelBboxes;\n\n    if (options.isEqualSize === true) {\n      if (!panelBboxes.default) {\n        const defaultPanel = panels[0];\n        panelBboxes.default = defaultPanel.getBbox();\n      }\n\n      const defaultBbox = panelBboxes.default;\n\n      panels.forEach(panel => {\n        panel.resize(defaultBbox);\n      });\n      return;\n    } else if (options.isEqualSize) {\n      const equalSizeClasses = options.isEqualSize;\n\n      panels.forEach(panel => {\n        const overlappedClass = panel.getOverlappedClass(equalSizeClasses);\n        if (overlappedClass) {\n          panel.resize(panelBboxes[overlappedClass]);\n          panelBboxes[overlappedClass] = panel.getBbox();\n        } else {\n          panel.resize();\n        }\n      });\n      return;\n    }\n    panels.forEach(panel => {\n      panel.resize();\n    });\n  }\n\n  private createPanInput() {\n    const options = this.options;\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      iOSEdgeSwipeThreshold: options.iOSEdgeSwipeThreshold,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n      releaseOnScroll: true,\n    });\n\n    this.axes.connect(options.horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n}\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../Flicking\";\n\nclass AutoResizer {\n  private flicking: Flicking;\n  private enabled: boolean;\n  private resizeObserver: ResizeObserver | null;\n\n  private skipFirstResize = (() => {\n    let isFirstResize = true;\n\n    return (() => {\n      if (isFirstResize) {\n        isFirstResize = false;\n        return;\n      }\n      this.onResize();\n    });\n  })();\n\n  public constructor(flicking: Flicking) {\n    this.flicking = flicking;\n    this.enabled = false;\n    this.resizeObserver = null;\n  }\n\n  public enable(): this {\n    const flicking = this.flicking;\n\n    if (this.enabled) {\n      this.disable();\n    }\n\n    if (flicking.options.useResizeObserver && !!window.ResizeObserver) {\n      const flickingEl = flicking.getElement();\n      const viewportSizeNot0 = flickingEl.clientWidth !== 0 || flickingEl.clientHeight !== 0;\n\n      const resizeObserver = viewportSizeNot0\n        ? new ResizeObserver(this.skipFirstResize)\n        : new ResizeObserver(this.onResize);\n\n      resizeObserver.observe(flickingEl);\n\n      this.resizeObserver = resizeObserver;\n    } else {\n      window.addEventListener(\"resize\", this.onResize);\n    }\n\n    this.enabled = true;\n\n    return this;\n  }\n\n  public disable(): this {\n    if (!this.enabled) {\n      return this;\n    }\n\n    const resizeObserver = this.resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      this.resizeObserver = null;\n    } else {\n      window.removeEventListener(\"resize\", this.onResize);\n    }\n\n    this.enabled = false;\n\n    return this;\n  }\n\n  private onResize = () => {\n    this.flicking.resize();\n  }\n}\n\nexport default AutoResizer;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Component from \"@egjs/component\";\nimport ImReady from \"@egjs/imready\";\nimport { DiffResult } from \"@egjs/list-differ\";\nimport Viewport from \"./components/Viewport\";\nimport Panel from \"./components/Panel\";\nimport AutoResizer from \"./components/AutoResizer\";\n\nimport { merge, getProgress, parseElement, isString, counter, findIndex } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE, DEFAULT_MOVE_TYPE_OPTIONS } from \"./consts\";\nimport {\n  FlickingOptions,\n  FlickingEvent,\n  Direction,\n  EventType,\n  FlickingPanel,\n  TriggerCallback,\n  FlickingContext,\n  FlickingStatus,\n  Plugin,\n  ElementLike,\n  DestroyOption,\n  BeforeSyncResult,\n  SyncResult,\n  ChangeEvent,\n  SelectEvent,\n  NeedPanelEvent,\n  VisibleChangeEvent,\n  ContentLoadEvent,\n  ContentErrorEvent,\n  MoveTypeStringOption,\n  ValueOf,\n} from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n */\nclass Flicking extends Component<{\n  holdStart: FlickingEvent;\n  holdEnd: FlickingEvent;\n  moveStart: FlickingEvent;\n  move: FlickingEvent;\n  moveEnd: FlickingEvent;\n  change: ChangeEvent;\n  restore: FlickingEvent;\n  select: SelectEvent;\n  needPanel: NeedPanelEvent;\n  visibleChange: VisibleChangeEvent;\n  contentLoad: ContentLoadEvent;\n  contentError: ContentErrorEvent;\n}> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @type {object}\n   * @property {\"PREV\"} PREV - Prev direction from current hanger position.<br/>It's `left(←️)` direction when `horizontal: true`.<br/>Or, `up(↑️)` direction when `horizontal: false`.<ko>현재 행어를 기준으로 이전 방향.<br/>`horizontal: true`일 경우 `왼쪽(←️)` 방향.<br/>`horizontal: false`일 경우 `위쪽(↑️)`방향이다.</ko>\n   * @property {\"NEXT\"} NEXT - Next direction from current hanger position.<br/>It's `right(→)` direction when `horizontal: true`.<br/>Or, `down(↓️)` direction when `horizontal: false`.<ko>현재 행어를 기준으로 다음 방향.<br/>`horizontal: true`일 경우 `오른쪽(→)` 방향.<br/>`horizontal: false`일 경우 `아래쪽(↓️)`방향이다.</ko>\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event type object with event name strings.\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   * @type {object}\n   * @property {\"holdStart\"} HOLD_START - holdStart event<ko>holdStart 이벤트</ko>\n   * @property {\"holdEnd\"} HOLD_END - holdEnd event<ko>holdEnd 이벤트</ko>\n   * @property {\"moveStart\"} MOVE_START - moveStart event<ko>moveStart 이벤트</ko>\n   * @property {\"move\"} MOVE - move event<ko>move 이벤트</ko>\n   * @property {\"moveEnd\"} MOVE_END - moveEnd event<ko>moveEnd 이벤트</ko>\n   * @property {\"change\"} CHANGE - change event<ko>change 이벤트</ko>\n   * @property {\"restore\"} RESTORE - restore event<ko>restore 이벤트</ko>\n   * @property {\"select\"} SELECT - select event<ko>select 이벤트</ko>\n   * @property {\"needPanel\"} NEED_PANEL - needPanel event<ko>needPanel 이벤트</ko>\n   * @example\n   * eg.Flicking.EVENTS.MOVE_START; // \"MOVE_START\"\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private autoResizer: AutoResizer;\n  private contentsReadyChecker: ImReady | null = null;\n\n  private eventContext: FlickingContext;\n  private isPanelChangedAtBeforeSync: boolean = false;\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options An option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix of class names will be added for the panels, viewport, and camera.<ko>패널들과 뷰포트, 카메라에 추가될 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation for animation triggered by manual user input. A higher value means a shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] The direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for continuous scrolling.<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능하다.</ko>\n   * @param {boolean} [options.infinite=false] Enables infinite mode, which can automatically trigger needPanel until reaching the last panel's index reaches the lastIndex.<ko>무한 모드를 활성화한다. 무한 모드에서는 needPanel 이벤트를 자동으로 트리거한다. 해당 동작은 마지막 패널의 인덱스가 lastIndex와 일치할때까지 일어난다.</ko>\n   * @param {number} [options.infiniteThreshold=0] A Threshold from viewport edge before triggering `needPanel` event in infinite mode.<ko>무한 모드에서 `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리.</ko>\n   * @param {number} [options.lastIndex=Infinity] Maximum panel index that Flicking can set. Flicking won't trigger `needPanel` when the event's panel index is greater than it.<br/>Also, if the last panel's index reached a given index, you can't add more panels.<ko>Flicking이 설정 가능한 패널의 최대 인덱스. `needPanel` 이벤트에 지정된 인덱스가 최대 패널의 개수보다 같거나 커야 하는 경우에 이벤트를 트리거하지 않게 한다.<br>또한, 마지막 패널의 인덱스가 주어진 인덱스와 동일할 경우, 새로운 패널을 더 이상 추가할 수 없다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to change panel(unit: pixel). It should be dragged above the threshold to change the current panel.<ko>패널 변경을 위한 이동 임계값 (단위: 픽셀). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement animation. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] An easing function applied to the panel movement animation. Default value is `easeOutCubic`.<ko>패널 이동 애니메이션에 적용할 easing함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of the panel to set as default when initializing. A zero-based integer.<ko>초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices to enable.({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Reference})<ko>활성화할 입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 참고})</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold angle value(0 ~ 90).<br>If the input angle from click/touched position is above or below this value in horizontal and vertical mode each, scrolling won't happen.<ko>스크롤 동작을 막기 위한 임계각(0 ~ 90).<br>클릭/터치한 지점으로부터 계산된 사용자 입력의 각도가 horizontal/vertical 모드에서 각각 크거나 작으면, 스크롤 동작이 이루어지지 않는다.</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`.<br>You can set different bounce value for prev/next direction by using array.<br>`number` for px value, and `string` for px, and % value relative to viewport size.(ex - 0, \"10px\", \"20%\")<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.<br>배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정 가능하다.<br>`number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있다.(ex - 0, \"10px\", \"20%\")</ko>\n   * @param {boolean} [options.autoResize=false] Whether the `resize` method should be called automatically after a window resize event.<ko>window의 `resize` 이벤트 이후 자동으로 resize()메소드를 호출할지의 여부.</ko>\n   * @param {boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number|\"\"} [options.zIndex=2000] z-index value for viewport element.<ko>뷰포트 엘리먼트의 z-index 값.</ko>\n   * @param {boolean} [options.bound=false] Prevent the view from going out of the first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] The reference position of the hanger in the viewport, which hangs panel anchors should be stopped at.<br>It should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] The reference position of the anchor in panels, which can be hanged by viewport hanger.<br>It should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space value between panels. Should be given in number.(px)<ko>패널간에 부여할 간격의 크기를 나타내는 숫자.(px)</ko>\n   * @param {eg.Flicking.MoveTypeOption} [options.moveType=\"snap\"] Movement style by user input. (ex: snap, freeScroll)<ko>사용자 입력에 의한 이동 방식.(ex: snap, freeScroll)</ko>\n   * @param {boolean} [options.useOffset=false] Whether to use `offsetWidth`/`offsetHeight` instead of `getBoundingClientRect` for panel/viewport size calculation.<br/>You can use this option to calculate the original panel size when CSS transform is applied to viewport or panel.<br/>⚠️ If panel size is not fixed integer value, there can be a 1px gap between panels.<ko>패널과 뷰포트의 크기를 계산할 때 `offsetWidth`/`offsetHeight`를 `getBoundingClientRect` 대신 사용할지 여부.<br/>패널이나 뷰포트에 CSS transform이 설정되어 있을 때 원래 패널 크기를 계산하려면 옵션을 활성화한다.<br/>⚠️ 패널의 크기가 정수로 고정되어있지 않다면 패널 사이에 1px의 공간이 생길 수 있다.</ko>\n   * @param {boolean} [options.renderOnlyVisible=false] Whether to render visible panels only. This can dramatically increase performance when there're many panels.<ko>보이는 패널만 렌더링할지 여부를 설정한다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있다.</ko>\n   * @param {boolean|string[]} [options.isEqualSize=false] This option indicates whether all panels have the same size(true) of first panel, or it can hold a list of class names that determines panel size.<br/>Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 동일한지(true), 혹은 패널 크기를 결정하는 패널 클래스들의 리스트.<br/>이 옵션을 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\n   * @param {boolean} [options.isConstantSize=false] Whether all panels have a constant size that won't be changed after resize. Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 불변인지의 여부. 이 옵션을 'true'로 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\n   * @param {boolean} [options.renderExternal=false] Whether to use external rendering. It will delegate DOM manipulation and can synchronize the rendered state by calling `sync()` method. You can use this option to use in frameworks like React, Vue, Angular, which has its states and rendering methods.<ko>외부 렌더링을 사용할 지의 여부. 이 옵션을 사용시 렌더링을 외부에 위임할 수 있고, `sync()`를 호출하여 그 상태를 동기화할 수 있다. 이 옵션을 사용하여, React, Vue, Angular 등 자체적인 상태와 렌더링 방법을 갖는 프레임워크에 대응할 수 있다.</ko>\n   * @param {boolean} [options.resizeOnContentsReady=false] Whether to resize the Flicking after the image/video elements inside viewport are ready.<br/>Use this property to prevent wrong Flicking layout caused by dynamic image / video sizes.<ko>Flicking 내부의 이미지 / 비디오 엘리먼트들이 전부 로드되었을 때 Flicking의 크기를 재계산하기 위한 옵션.<br/>이미지 / 비디오 크기가 고정 크기가 아닐 경우 사용하여 레이아웃이 잘못되는 것을 방지할 수 있다.</ko>\n   * @param {boolean} [options.useResizeObserver=true] Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option<ko>autoResize 옵션 사용시 {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}의 이벤트를 Window객체의 {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} 이벤트 대신 수신할지 여부를 설정합니다</ko>\n   * @param {boolean} [options.collectStatistics=true] Whether to collect statistics on how you are using `Flicking`. These statistical data do not contain any personal information and are used only as a basis for the development of a user-friendly product.<ko>어떻게 `Flicking`을 사용하고 있는지에 대한 통계 수집 여부를 나타낸다. 이 통계자료는 개인정보를 포함하고 있지 않으며 오직 사용자 친화적인 제품으로 발전시키기 위한 근거자료로서 활용한다.</ko>\n   */\n  constructor(\n    element: string | HTMLElement,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Override moveType option\n    const currentOptions = this.options;\n    const moveType = currentOptions.moveType as MoveTypeStringOption;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType as keyof typeof DEFAULT_MOVE_TYPE_OPTIONS];\n    }\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(this, this.options, this.triggerEvent);\n    this.autoResizer = new AutoResizer(this);\n\n    this.listenInput();\n    this.listenResize();\n  }\n\n  /**\n   * Move to the previous panel if it exists.\n   * @ko 이전 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public prev(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const prevPanel = currentPanel.prev();\n      if (prevPanel) {\n        prevPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the next panel if it exists.\n   * @ko 다음 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation(unit: ms).<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public next(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const nextPanel = currentPanel.next();\n      if (nextPanel) {\n        nextPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the panel of given index.\n   * @ko 주어진 인덱스에 해당하는 패널로 이동한다.\n   * @param index The index number of the panel to move.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    const state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = viewport.getHangerPosition();\n\n    let targetPanel = panel;\n    if (this.options.circular) {\n      const scrollAreaSize = viewport.getScrollAreaSize();\n      // Check all three possible locations, find the nearest position among them.\n      const possiblePositions = [\n        anchorPosition - scrollAreaSize,\n        anchorPosition,\n        anchorPosition + scrollAreaSize,\n      ];\n      const nearestPosition = possiblePositions.reduce((nearest, current) => {\n        return (Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition))\n          ? current\n          : nearest;\n      }, Infinity) - panel.getRelativeAnchorPosition();\n\n      const identicals = panel.getIdenticalPanels();\n      const offset = nearestPosition - anchorPosition;\n      if (offset > 0) {\n        // First cloned panel is nearest\n        targetPanel = identicals[1];\n      } else if (offset < 0) {\n        // Last cloned panel is nearest\n        targetPanel = identicals[identicals.length - 1];\n      }\n\n      targetPanel = targetPanel.clone(targetPanel.getCloneIndex(), true);\n      targetPanel.setPosition(nearestPosition);\n    }\n    const currentIndex = this.getIndex();\n\n    if (hangerPosition === targetPanel.getAnchorPosition() && currentIndex === index) {\n      return this;\n    }\n\n    const eventType = panel.getIndex() === viewport.getCurrentIndex()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      targetPanel,\n      viewport.findEstimatedPosition(targetPanel),\n      eventType,\n      null,\n      duration,\n    );\n    return this;\n  }\n\n  /**\n   * Return index of the current panel. `-1` if no panel exists.\n   * @ko 현재 패널의 인덱스 번호를 반환한다. 패널이 하나도 없을 경우 `-1`을 반환한다.\n   * @return Current panel's index, zero-based integer.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getCurrentIndex();\n  }\n\n  /**\n   * Return the wrapper element user provided in constructor.\n   * @ko 사용자가 생성자에서 제공한 래퍼 엘리먼트를 반환한다.\n   * @return Wrapper element user provided.<ko>사용자가 제공한 래퍼 엘리먼트.</ko>\n   */\n  public getElement(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Return the viewport element's size.\n   * @ko 뷰포트 엘리먼트의 크기를 반환한다.\n   * @return Width if horizontal: true, height if horizontal: false\n   */\n  public getSize(): number {\n    return this.viewport.getSize();\n  }\n\n  /**\n   * Return current panel. `null` if no panel exists.\n   * @ko 현재 패널을 반환한다. 패널이 하나도 없을 경우 `null`을 반환한다.\n   * @return Current panel.<ko>현재 패널.</ko>\n   */\n  public getCurrentPanel(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel();\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return the panel of given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 패널을 반환한다. 해당 패널이 존재하지 않을 시 `null`이다.\n   * @return Panel of given index.<ko>주어진 인덱스에 해당하는 패널.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return all panels.\n   * @ko 모든 패널들을 반환한다.\n   * @param - Should include cloned panels or not.<ko>복사된 패널들을 포함할지의 여부.</ko>\n   * @return All panels.<ko>모든 패널들.</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const panels = includeClone\n      ? panelManager.allPanels()\n      : panelManager.originalPanels();\n\n    return panels\n      .filter(panel => !!panel);\n  }\n\n  /**\n   * Return the panels currently shown in viewport area.\n   * @ko 현재 뷰포트 영역에서 보여지고 있는 패널들을 반환한다.\n   * @return Panels currently shown in viewport area.<ko>현재 뷰포트 영역에 보여지는 패널들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.viewport.calcVisiblePanels();\n  }\n\n  /**\n   * Return length of original panels.\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.panelManager.getPanelCount();\n  }\n\n  /**\n   * Return how many groups of clones are created.\n   * @ko 몇 개의 클론 그룹이 생성되었는지를 반환한다.\n   * @return Length of cloned panel groups.<ko>클론된 패널 그룹의 개수</ko>\n   */\n  public getCloneCount(): number {\n    return this.viewport.panelManager.getCloneCount();\n  }\n\n  /**\n   * Get maximum panel index for `infinite` mode.\n   * @ko `infinite` 모드에서 적용되는 추가 가능한 패널의 최대 인덱스 값을 반환한다.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return Maximum index of panel that can be added.<ko>최대 추가 가능한 패널의 인덱스.</ko>\n   */\n  public getLastIndex(): number {\n    return this.viewport.panelManager.getLastIndex();\n  }\n\n  /**\n   * Set maximum panel index for `infinite' mode.<br>[needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it.<br>Also, you can't add more panels after it.\n   * @ko `infinite` 모드에서 적용되는 패널의 최대 인덱스를 설정한다.<br>마지막 패널의 인덱스가 설정한 값에 도달할 경우 더 이상 [needPanel]{@link eg.Flicking#events:needPanel} 이벤트가 발생되지 않는다.<br>또한, 설정한 인덱스 이후로 새로운 패널을 추가할 수 없다.\n   * @param - Maximum panel index.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public setLastIndex(index: number): this {\n    this.viewport.setLastIndex(index);\n\n    return this;\n  }\n\n  /**\n   * Return panel movement animation.\n   * @ko 현재 패널 이동 애니메이션이 진행 중인지를 반환한다.\n   * @return Is animating or not.<ko>애니메이션 진행 여부.</ko>\n   */\n  public isPlaying(): boolean {\n    return this.viewport.stateMachine.getState().playing;\n  }\n\n  /**\n   * Unblock input devices.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * Block input devices.\n   * @ko 입력 장치로부터의 입력을 막는다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to [setStatus()]{@link eg.Flicking#setStatus}.\n   * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있다.\n   * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus(): FlickingStatus {\n    const viewport = this.viewport;\n\n    const panels = viewport.panelManager.originalPanels()\n      .filter(panel => !!panel)\n      .map(panel => {\n        return {\n          html: panel.getElement().outerHTML,\n          index: panel.getIndex(),\n          position: panel.getPosition(),\n        };\n      });\n\n    return {\n      index: viewport.getCurrentIndex(),\n      panels,\n      position: viewport.getCameraPosition(),\n    };\n  }\n\n  /**\n   * Restore to the state of the `status`.\n   * @ko `status`의 상태로 복원한다.\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n   */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking.\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add.<ko>추가할 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.addPlugins(plugins);\n    return this;\n  }\n\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.removePlugins(plugins);\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(option: Partial<DestroyOption> = {}): void {\n    this.off();\n\n    this.autoResizer.disable();\n    this.viewport.destroy(option);\n    this.contentsReadyChecker?.destroy();\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * Update panels to current state.\n   * @ko 패널들을 현재 상태에 맞춰 갱신한다.\n   * @method\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public resize = (): this => {\n    const viewport = this.viewport;\n    const options = this.options;\n    const wrapper = this.getElement();\n\n    const allPanels = viewport.panelManager.allPanels();\n    if (!options.isConstantSize) {\n      allPanels\n        .filter(panel => !!panel)\n        .forEach(panel => panel.unCacheBbox());\n    }\n\n    const shouldResetElements = options.renderOnlyVisible\n      && !options.isConstantSize\n      && options.isEqualSize !== true;\n\n    // Temporarily set parent's height to prevent scroll (#333)\n    const parent = wrapper.parentElement!;\n    const origStyle = parent.style.height;\n    parent.style.height = `${parent.offsetHeight}px`;\n\n    viewport.unCacheBbox();\n    // This should be done before adding panels, to lower performance issue\n    viewport.updateBbox();\n\n    if (shouldResetElements) {\n      viewport.appendUncachedPanelElements(allPanels as Panel[]);\n    }\n\n    viewport.resize();\n    parent.style.height = origStyle;\n\n    return this;\n  }\n\n  /**\n   * Add new panels at the beginning of panels.\n   * @ko 제일 앞에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 0, pushing every panels behind it.\n   */\n  public prepend(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n\n    const insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    const prependedPanels = viewport.insert(insertingIndex, parsedElements);\n\n    this.checkContentsReady(prependedPanels);\n\n    return prependedPanels;\n  }\n\n  /**\n   * Add new panels at the end of panels.\n   * @ko 제일 끝에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\n   */\n  public append(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const appendedPanels = viewport.insert(viewport.panelManager.getRange().max + 1, element);\n\n    this.checkContentsReady(appendedPanels);\n\n    return appendedPanels;\n  }\n\n  /**\n   * Replace existing panels with new panels from given index. If target index is empty, add new panel at target index.\n   * @ko 주어진 인덱스로부터의 패널들을 새로운 패널들로 교체한다. 인덱스에 해당하는 자리가 비어있다면, 새로운 패널을 해당 자리에 집어넣는다.\n   * @param index - Start index to replace new panels.<ko>새로운 패널들로 교체할 시작 인덱스</ko>\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of created panels by replace.<ko>교체되어 새롭게 추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   *\n   * // This will add new panel at index 3,\n   * // Index 0, 1, 2 is empty at this moment.\n   * // [empty, empty, empty, PANEL]\n   * flicking.replace(3, document.createElement(\"div\"));\n   *\n   * // As index 2 was empty, this will also add new panel at index 2.\n   * // [empty, empty, PANEL, PANEL]\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\n   *\n   * // Index 3 was not empty, so it will replace previous one.\n   * // It will also add new panels at index 4 and 5.\n   * // before - [empty, empty, PANEL, PANEL]\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\n   */\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const replacedPanels = this.viewport.replace(index, element);\n\n    this.checkContentsReady(replacedPanels);\n\n    return replacedPanels;\n  }\n\n  /**\n   * Remove panel at target index. This will decrease index of panels behind it.\n   * @ko `index`에 해당하는 자리의 패널을 제거한다. 수행시 `index` 이후의 패널들의 인덱스가 감소된다.\n   * @param index - Index of panel to remove.<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index` 이후로 제거할 패널의 개수.</ko>\n   * @return Array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    return this.viewport.remove(index, deleteCount);\n  }\n\n  /**\n   * Get indexes to render. Should be used with `renderOnlyVisible` option.\n   * `beforeSync` should be called before this method for a correct result.\n   * @private\n   * @ko 렌더링이 필요한 인덱스들을 반환한다. `renderOnlyVisible` 옵션과 함께 사용해야 한다. 정확한 결과를 위해선 `beforeSync`를 이전에 호출해야만 합니다.\n   * @param - Info object of how panel infos are changed.<ko>패널 정보들의 변경 정보를 담는 오브젝트.</ko>\n   * @return Array of indexes to render.<ko>렌더링할 인덱스의 배열</ko>\n   */\n  public getRenderingIndexes(diffResult: DiffResult<any>): number[] {\n    const viewport = this.viewport;\n    const visiblePanels = viewport.getVisiblePanels();\n    const maintained = diffResult.maintained.reduce((values: {[key: number]: number}, [before, after]) => {\n      values[after] = before;\n      return values;\n    }, {});\n\n    const panelCount = diffResult.list.length;\n    const added = diffResult.added;\n    const getPanelAbsIndex = (panel: Panel) => {\n      return panel.getIndex() + (panel.getCloneIndex() + 1) * panelCount;\n    };\n\n    const visibleIndexes = visiblePanels.map(panel => getPanelAbsIndex(panel))\n      .filter(val => maintained[val % panelCount] != null);\n\n    const renderingPanels = [...visibleIndexes, ...added];\n    const allPanels = viewport.panelManager.allPanels();\n\n    viewport.setVisiblePanels(renderingPanels.map(index => allPanels[index]));\n\n    return renderingPanels;\n  }\n\n  /**\n   * Synchronize info of panels instance with info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 입력받은 패널의 정보와 현재 플리킹이 갖는 패널 정보를 동기화한다.\n   * @private\n   * @param - Info object of how panel infos are changed.<ko>패널 정보들의 변경 정보를 담는 오브젝트.</ko>\n   * @param - Whether called from sync method <ko> sync 메소드로부터 호출됐는지 여부 </ko>\n   */\n  public beforeSync(diffInfo: BeforeSyncResult) {\n    const { maintained, added, changed, removed } = diffInfo;\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const isCircular = this.options.circular;\n    const currentPanel = viewport.getCurrentPanel();\n    const cloneCount = panelManager.getCloneCount();\n    const prevClonedPanels = panelManager.clonedPanels();\n\n    // Update visible panels\n    const newVisiblePanels = viewport.getVisiblePanels()\n      .filter(panel => findIndex(removed, index => {\n        return index === panel.getIndex();\n      }) < 0);\n    viewport.setVisiblePanels(newVisiblePanels);\n\n    // Did not changed at all\n    if (\n      added.length <= 0\n      && removed.length <= 0\n      && changed.length <= 0\n      && cloneCount === prevClonedPanels.length\n    ) {\n      return this;\n    }\n    const prevOriginalPanels = panelManager.originalPanels();\n    const newPanels: Panel[] = [];\n    const newClones: Panel[][] = counter(cloneCount).map(() => []);\n\n    maintained.forEach(([beforeIdx, afterIdx]) => {\n      newPanels[afterIdx] = prevOriginalPanels[beforeIdx];\n      newPanels[afterIdx].setIndex(afterIdx);\n    });\n\n    added.forEach(addIndex => {\n      newPanels[addIndex] = new Panel(null, addIndex, this.viewport);\n    });\n\n    if (isCircular) {\n      counter(cloneCount).forEach(groupIndex => {\n        const prevCloneGroup = prevClonedPanels[groupIndex];\n        const newCloneGroup = newClones[groupIndex];\n\n        maintained.forEach(([beforeIdx, afterIdx]) => {\n          newCloneGroup[afterIdx] = prevCloneGroup\n            ? prevCloneGroup[beforeIdx]\n            : newPanels[afterIdx].clone(groupIndex, false);\n\n          newCloneGroup[afterIdx].setIndex(afterIdx);\n        });\n\n        added.forEach(addIndex => {\n          const newPanel = newPanels[addIndex];\n\n          newCloneGroup[addIndex] = newPanel.clone(groupIndex, false);\n        });\n      });\n    }\n\n    added.forEach(index => { viewport.updateCheckedIndexes({ min: index, max: index }); });\n    removed.forEach(index => { viewport.updateCheckedIndexes({ min: index - 1, max: index + 1 }); });\n\n    const checkedIndexes = viewport.getCheckedIndexes();\n    checkedIndexes.forEach(([min, max], idx) => {\n      // Push checked indexes backward\n      const pushedIndex = added.filter(index => index < min && panelManager.has(index)).length\n        - removed.filter(index => index < min).length;\n      checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n    });\n\n    // Only effective only when there are least one panel which have changed its index\n    if (changed.length > 0) {\n      // Removed checked index by changed ones after pushing\n      maintained.forEach(([, next]) => { viewport.updateCheckedIndexes({ min: next, max: next }); });\n    }\n    panelManager.replacePanels(newPanels, newClones);\n\n    const currentPanelIndex = currentPanel?.getIndex() ?? -1;\n    const currentPanelIsRemoved = findIndex(removed, index => index === currentPanelIndex) >= 0;\n\n    if ((!currentPanel || currentPanelIsRemoved) && newPanels.length > 0) {\n      viewport.setCurrentPanel(newPanels[0]);\n    } else if (newPanels.length <= 0) {\n      viewport.setCurrentPanel(undefined);\n    }\n\n    this.isPanelChangedAtBeforeSync = true;\n  }\n\n  /**\n   * Synchronize info of panels with DOM info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 입력받은 DOM의 정보와 현재 플리킹이 갖는 패널 정보를 동기화 한다.\n   * @private\n   * @param - Info object of how panel elements are changed.<ko>패널의 DOM 요소들의 변경 정보를 담는 오브젝트.</ko>\n   */\n  public sync(diffInfo: SyncResult): this {\n    const { list, maintained, added, changed, removed } = diffInfo;\n\n    // Did not changed at all\n    if (added.length <= 0 && removed.length <= 0 && changed.length <= 0) {\n      return this;\n    }\n    const viewport = this.viewport;\n    const { renderOnlyVisible, circular } = this.options;\n    const panelManager = viewport.panelManager;\n\n    if (!renderOnlyVisible) {\n      const indexRange = panelManager.getRange();\n      let beforeDiffInfo: BeforeSyncResult = diffInfo;\n\n      if (circular) {\n        const prevOriginalPanelCount = indexRange.max;\n        const originalPanelCount = (list.length / (panelManager.getCloneCount() + 1)) >> 0;\n        const originalAdded = added.filter(index => index < originalPanelCount);\n        const originalRemoved = removed.filter(index => index <= prevOriginalPanelCount);\n        const originalMaintained = maintained.filter(([beforeIdx]) => beforeIdx <= prevOriginalPanelCount);\n        const originalChanged = changed.filter(([beforeIdx]) => beforeIdx <= prevOriginalPanelCount);\n\n        beforeDiffInfo = {\n          added: originalAdded,\n          maintained: originalMaintained,\n          removed: originalRemoved,\n          changed: originalChanged,\n        };\n      }\n      this.beforeSync(beforeDiffInfo);\n    }\n\n    const visiblePanels = renderOnlyVisible\n      ? viewport.getVisiblePanels()\n      : this.getAllPanels(true);\n\n    added.forEach(addedIndex => {\n      const addedElement = list[addedIndex];\n      const beforePanel = visiblePanels[addedIndex] as Panel;\n\n      beforePanel.setElement(addedElement);\n      // As it can be 0\n      beforePanel.unCacheBbox();\n    });\n    if (this.isPanelChangedAtBeforeSync) {\n      // Reset visible panels\n      viewport.setVisiblePanels([]);\n      this.isPanelChangedAtBeforeSync = false;\n    }\n    viewport.resize();\n\n    return this;\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const viewport = flicking.viewport;\n    const stateMachine = viewport.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    const options = this.options;\n\n    if (options.autoResize) {\n      this.autoResizer.enable();\n    }\n\n    if (options.resizeOnContentsReady) {\n      const contentsReadyChecker = new ImReady();\n\n      const onContentLoad = () => {\n        this.resize();\n        this.trigger(EVENTS.CONTENT_LOAD, {\n          type: EVENTS.CONTENT_LOAD,\n        });\n      };\n\n      contentsReadyChecker.on(\"preReady\", onContentLoad);\n      contentsReadyChecker.on(\"readyElement\", e => {\n        if (e.hasLoading && e.isPreReadyOver) {\n          onContentLoad();\n        }\n      });\n      contentsReadyChecker.on(\"error\", e => {\n        this.trigger(EVENTS.CONTENT_ERROR, {\n          type: EVENTS.CONTENT_ERROR,\n          element: e.element,\n        });\n      });\n      contentsReadyChecker.check([this.wrapper]);\n\n      this.contentsReadyChecker = contentsReadyChecker;\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: ValueOf<Omit<EventType, \"VISIBLE_CHANGE\">>, // visibleChange event has no common event definition from other events\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n\n    let canceled: boolean = true;\n\n    // Ignore events before viewport is initialized\n    if (viewport) {\n      const state = viewport.stateMachine.getState();\n      const { prev, next } = viewport.getScrollArea();\n      const pos = viewport.getCameraPosition();\n      let progress = getProgress(pos, [prev, prev, next]);\n\n      if (this.options.circular) {\n        progress %= 1;\n      }\n      canceled = !super.trigger(eventName, merge({\n        type: eventName,\n        index: this.getIndex(),\n        panel: this.getCurrentPanel(),\n        direction: state.direction,\n        holding: state.holding,\n        progress,\n        axesEvent,\n        isTrusted,\n      }, params) as FlickingEvent);\n    }\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = viewport.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n    const previousPosition = viewport.getCameraPosition();\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNextDirection = inputOffset < 0;\n\n      let cameraChange = pos - previousPosition;\n      const looped = isNextDirection === (pos < previousPosition);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = (cameraChange > 0 ? -1 : 1) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.direction = currentDirection;\n    }\n    state.delta += axesEvent.delta.flick;\n\n    viewport.moveCamera(pos, axesEvent);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted)\n      .onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n  }\n\n  private checkContentsReady(panels: FlickingPanel[]) {\n    this.contentsReadyChecker?.check(panels.map(panel => panel.getElement()));\n  }\n}\n\nexport default Flicking;\n"],"names":["MOVE_TYPE","SNAP","FREE_SCROLL","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","isBrowser","document","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","Math","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","useOffset","isEqualSize","isConstantSize","renderOnlyVisible","renderExternal","resizeOnContentsReady","iOSEdgeSwipeThreshold","collectStatistics","useResizeObserver","DEFAULT_VIEWPORT_CSS","position","DEFAULT_CAMERA_CSS","width","height","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","VISIBLE_CHANGE","CONTENT_LOAD","CONTENT_ERROR","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","IDLE","HOLDING","DRAGGING","ANIMATING","DISABLED","DIRECTION","PREV","NEXT","FLICKING_METHODS","prev","next","moveTo","getIndex","getAllPanels","getCurrentPanel","getElement","getSize","getPanel","getPanelCount","getStatus","getVisiblePanels","enableInput","disableInput","destroy","resize","setStatus","isPlaying","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","name","has3d","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","el","createElement","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","length","TRANSFORM","merge","target","_i","srcs","forEach","source","Object","keys","key","value","parseElement","element","Array","isArray","elements","isString","tempDiv","innerHTML","push","toArray","children","firstChild","addClass","className","classList","add","hasClass","replace","contains","split","indexOf","applyCSS","cssObj","property","clamp","val","min","max","isBetween","iterable","slice","call","arr","constructor","parseArithmeticExpression","cssValue","base","defaultVal","defaultValue","cssRegex","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","getProgress","pos","range","center","findIndex","callback","i","counter","counterArray","circulate","indexed","size","offset","restoreStyle","originalStyle","setAttribute","removeAttribute","withFlickingMethods","prototype","flickingName","args","result","_a","getBbox","bbox","y","offsetWidth","offsetHeight","clientRect","getBoundingClientRect","left","top","index","viewport","prevSibling","nextSibling","clonedPanels","state","relativeAnchorPosition","isClone","isVirtual","cloneIndex","cachedBbox","setElement","givenBbox","options","prevSize","panel","cloneState","panelCount","panelManager","scrollAreaSize","getScrollAreaSize","relativeIndex","floor","getPosition","progress","getCurrentProgress","outsetRange","getRelativeHangerPosition","getRelativeAnchorPosition","relativePanelPosition","getCameraPosition","outsetProgress","panelSize","rightRelativePanelPosition","visibleSize","visibleRatio","currentPanel","hangerPosition","getHangerPosition","anchorPosition","getAnchorPosition","currentPosition","eventType","findEstimatedPosition","updateFunction","shouldResize","identicalPanels","getIdenticalPanels","eachPanel","unCacheBbox","addVisiblePanel","currentIndex","prevPanelIndex","prevPanelPosition","prevPanelSize","hasEmptyPanelBetween","notYetMinPanel","newPosition","prevPanel","clone","getCloneIndex","setPosition","getLastIndex","nextPanelIndex","nextPanelPosition","notYetMaxPanel","nextPanel","parsedElements","firstPanel","targetIndex","insert","remove","option","preserveUI","wasVisible","Boolean","parentNode","cameraElement","getCameraElement","appendChild","classes","classes_1","original","getClonedPanels","elementStyle","currentElementStyle","styleToApply","cloneElement","cloneNode","clonedPanel","Panel","clonedState","removeClonedPanelsAfter","start","removingPanels","splice","removeElement","currentElement","getAttribute","panels","clones","cloneCount","reduce","allClones","newPanels","newClones","filter","chainAllPanels","lastPanel","firstRemovedPanel","possibleLastPanel","shouldRender","isCircular","findFirstPanelFrom","siblingElement","insertNewPanels","pushedIndex","panelsAfterIndex","emptyPanelCount","removedPanels","newLastIndex","concat","reverse","setIndex","updateIndex","addNewClones","panelCount_1","cloneSet","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","reversedPanels","nonEmptyIndexFromLast","allPanels","allPanelsCount","newClones_1","insertTarget_1","allPanels_1","panelElement","originalPanels","getCloneCount","lastPanelClones","nextSiblingClones","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","map","_this","this_1","insertClones","insertingIndex","fragment_1","createDocumentFragment","prevState","delta","direction","targetPanel","lastPosition","nextState","e","context","__extends","flicking","triggerEvent","transitTo","moveCamera","onSuccess","onStopped","onChange","State","inputEvent","offsetX","offsetY","flick","setTo","srcEvent","cancelable","releaseEvent","clickedElement","touchEvent","touch","changedTouches","elementFromPoint","clientX","clientY","clickedPanel","findPanelOf","cameraPosition","clickedPanelPosition","stopCamera","absDelta","abs","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","moveTypeContext","axesEvent","interruptDestInfo","findPanelWhenInterrupted","destPos","nearestPanel","getNearestPanel","stop","destInfo","findTargetPanel","findRestorePanel","scrollArea","getScrollArea","loopCount","originalTargetPosition","newCloneIndex","newTargetPosition","newTargetPanel","setCurrentPanel","isTrusted","updateAdaptiveSize","updateCameraPosition","updateAxesPosition","IdleState","nextStateType","currentState","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onEnter","onHold","onRelease","onAnimationEnd","onFinish","ctx","findRestorePanelInCircularMode","halfGap","minimumDistanceToChange","originalPanel","getOriginalPanel","firstClonedPanel","lapped","_super","snapCount","eventDelta","calcBrinkOfChange","nearestIsCurrent","shouldMoveWhenBounceIs0","canSetBoundMode","shouldMoveToAdjacent","isOutOfBound","findSnappedPanel","findAdjacentPanel","estimatedHangerPos","panelToMove","cycleIndex","passedPanelCount","panelPosition","panelNextPosition","panelPrevPosition","siblingPanel","panelIndex","siblingIndex","originalPosition","defaultDuration","getCurrentIndex","get","basePanel","basePosition","adjacentPanel","targetRelativeAnchorPosition","estimatedPanelPosition","estimatedPosition","MoveType","estimatedPanel","findNearestPanelAt","stateMachine","getState","currentPanelPosition","lastHangerPosition","Snap","panelMaintainRatio","relativeHangerPosition","positionOffset","translate","checkedIndexes","isAdaptiveCached","isViewportGiven","isCameraGiven","originalViewportStyle","originalCameraStyle","StateMachine","visiblePanels","panelBboxes","build","eventResult","axes","findNearestPanel","originalNearestPosition","checkNeedPanel","modifiedNearestPosition","updateVisiblePanels","posOffset","moveVector","moveCoord","coord","round","join","viewportElement","updateSize","updateOriginalPanelPositions","updateScrollArea","updateClonePanels","updateVisiblePanelPositions","updatePlugins","minimumDistance","prevPosition","nextPosition","distance","minimumAnchorDistance","anchorDistance","nearest","shortestDistance","identicals","identical","getVisibleIndexOf","panInput","createPanInput","setAxesInstance","resizePanels","newCenterPanel","newPanelPosition","updateCheckedIndexes","indexes","visibleIndex","wasEmpty","newCurrentIndex","getRange","undefined","shouldApplyAdaptive","viewportStyle","sizeToApply","panelBbox","maximumPanelSize","maximum","viewportBbox","updateBbox","viewportSize","isFreeScroll","is","holding","playing","positionBounded","plugins","plugin","update","wrapper","removePlugins","topmostElement_1","deletingElement","status","html","refreshPanels","createdPanels","orderedPanels","createdPanel","replacePanels","setCloneCount","cameraPos_1","viewportSize_1","getNextPanel","getPrevPanel","isOutOfBoundNext","isOutOfBoundPrev","getNext","isOutOfViewport","getAbsIndex_1","nextPanels","prevPanels","__spreadArrays","sort","panel1","panel2","getOutsetProgress","NaN","prevRange","nextRange","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","targetPosition","progressBetween","startIndex","off","on","axesHandlers","setLastIndex","handlers","newPlugins","init","currentPlugins","removedPlugins","changedRange","removed","fragment","prevVisiblePanels","equalSizeClasses_1","cached_1","overlappedClass","getOverlappedClass","clonePanels","updateClonedPanelPositions","visiblePanel","setElements","applyCSSValue","setMoveType","setDefaultPanel","moveToDefaultPanel","viewportCandidate","hasViewportElement","cameraCandidate","hasCameraElement","panelElements","child","minHeight","minWidth","PanelManager","FreeScroll","Axes","easing","interruptable","indexRange","sumOriginalPanelSize","areaPrev","sizeSum","panelAtLeftBoundary","reversedPanels_1","areaNext","panelAtRightBoundary","panels_1","needCloneOnPrev","panel0OnFirstscreen","ceil","prevCloneCount","origPanel","removeClonesAfter","defaultPanel","defaultPosition","nextPanelPos","maintainingPanel","looped","panelsBeforeMaintainPanel","accumulatedSize","total","setPositionCSS","clonedPanels_1","cloneBasePos","clonedPanelPos","lastReplacePosition","_b","replacePosition","relAnchorPosOfCombined","anchorPos","parsedBounce","parsedVal","axis","maxLastIndex","triggerNeedPanel","checkingPanel","atLastPanel","nextIndex","currentNearestPosition","panelRight","cameraNext","emptyPanelExistsBetween","firstIndex","lastPanelAfterNeed","atLastPanelAfterNeed","cameraPrev","checkingIndex","atFirstPanel","prevIndex","panelLeft","firstPanelAfterNeed","atFirstPanelAfterNeed","params","alreadyTriggered","some","hasHandler","hasOn","fill","insertAfter","newVisiblePanels","calcVisiblePanels","checkVisiblePanelChange","addedPanels","firstVisiblePanelPos","firstVisiblePanel","lastVisiblePanel","getAbsIndex","newVisibleRange","trigger","prevRefCount","newRefCount","newPanel","newIndex","added","default","defaultBbox_1","equalSizeClasses_2","PanInput","scale","releaseOnScroll","connect","isFirstResize","onResize","enabled","resizeObserver","disable","ResizeObserver","flickingEl","viewportSizeNot0","clientWidth","clientHeight","skipFirstResize","observe","addEventListener","disconnect","removeEventListener","shouldResetElements","parent","origStyle","appendUncachedPanelElements","eventName","canceled","previousPosition","inputOffset","cameraChange","currentDirection","querySelector","nodeName","nodeType","currentOptions","Viewport","autoResizer","AutoResizer","listenInput","listenResize","focus","possiblePositions","nearestPosition","current","includeClone","enable","outerHTML","restore","addPlugins","contentsReadyChecker","prependedPanels","checkContentsReady","appendedPanels","diffResult","maintained","values","before","after","list","getPanelAbsIndex","visibleIndexes","renderingPanels","setVisiblePanels","diffInfo","changed","prevClonedPanels","prevOriginalPanels","beforeIdx","afterIdx","addIndex","groupIndex","prevCloneGroup","newCloneGroup","getCheckedIndexes","has","currentPanelIndex","currentPanelIsRemoved","isPanelChangedAtBeforeSync","beforeDiffInfo","prevOriginalPanelCount_1","originalPanelCount_1","originalAdded","originalRemoved","originalMaintained","originalChanged","beforeSync","addedIndex","addedElement","beforePanel","eventContext","fire","connectAxesHandler","ImReady","onContentLoad_1","hasLoading","isPreReadyOver","check","Flicking","Component"],"mappings":"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"}